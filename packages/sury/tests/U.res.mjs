// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "../src/S.res.mjs";
import * as Stdlib_Dict from "rescript/lib/es6/Stdlib_Dict.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

let noopOpCode = S.makeConvertOrThrow(S.unknown, S.unknown, undefined).toString();

function throwError(error) {
  throw error;
}

function unsafeGetVariantPayload(variant) {
  return variant._0;
}

let Test = /* @__PURE__ */Primitive_exceptions.create("U.Test");

function throwTestException() {
  throw {
    RE_EXN_ID: Test,
    Error: new Error()
  };
}

function assertThrowsTestException(t, fn, message) {
  try {
    fn();
    return t.fail("Didn't throw");
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === Test) {
      t.pass(message !== undefined ? Primitive_option.valFromOption(message) : undefined);
      return;
    } else {
      return t.fail("Thrown another exception");
    }
  }
}

function assertThrows(t, cb, errorPayload) {
  let any;
  try {
    any = cb();
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === S.Exn) {
      t.is(exn._1.message, S.$$Error.make(errorPayload).message);
      return;
    }
    throw exn;
  }
  t.fail("Asserted result is not Error. Recieved: " + JSON.stringify(any));
}

function assertThrowsMessage(t, cb, errorMessage, message) {
  let any;
  try {
    any = cb();
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === S.Exn) {
      t.is(exn._1.message, errorMessage, message !== undefined ? Primitive_option.valFromOption(message) : undefined);
      return;
    }
    throw exn;
  }
  t.fail("Asserted result is not S.Exn \"" + errorMessage + "\". Instead got: " + JSON.stringify(any));
}

async function asyncAssertThrowsMessage(t, cb, errorMessage, message) {
  let any;
  try {
    any = await cb();
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === S.Exn) {
      t.is(exn._1.message, errorMessage, message !== undefined ? Primitive_option.valFromOption(message) : undefined);
      return;
    }
    throw exn;
  }
  return t.fail("Asserted result is not S.Exn \"" + errorMessage + "\". Instead got: " + JSON.stringify(any));
}

function getCompiledCodeString(schema, op) {
  let toCode = schema => (
    op === "ParseAsync" ? S.makeAsyncConvertOrThrow(S.unknown, schema, undefined) : (
        op === "Parse" ? S.makeConvertOrThrow(S.unknown, schema, undefined) : (
            op === "ReverseConvertToJson" ? S.makeConvertOrThrow(schema, S.json, undefined) : (
                op === "ReverseConvert" ? S.makeConvertOrThrow(schema, S.unknown, undefined) : (
                    op === "Convert" ? S.makeConvertOrThrow(S.reverse(schema), S.unknown, undefined) : (
                        op === "Assert" ? S.makeConvertOrThrow(S.unknown, S.to(schema, S.noValidation(S.literal(), true)), undefined) : (
                            op === "ReverseParse" ? S.makeConvertOrThrow(S.unknown, S.reverse(schema), undefined) : (
                                op === "ConvertAsync" ? S.makeAsyncConvertOrThrow(S.reverse(schema), S.unknown, undefined) : S.makeAsyncConvertOrThrow(schema, S.unknown, undefined)
                              )
                          )
                      )
                  )
              )
          )
      )
  ).toString();
  let code = {
    contents: toCode(schema)
  };
  let defs = schema.$defs;
  if (defs !== undefined && code.contents !== noopOpCode) {
    Stdlib_Dict.forEachWithKey(defs, (schema, key) => {
      try {
        let defCode = toCode(schema).replaceAll(S.unknown.seq.toString() + "-" + schema.seq.toString(), "unknown->" + key);
        code.contents = code.contents + "\n" + (key + ": " + defCode);
        return;
      } catch (_exn) {
        return;
      }
    });
  }
  return code.contents;
}

function cleanUpSchema(schema) {
  let $$new = {};
  Object.entries(schema).forEach(param => {
    let value = param[1];
    let key = param[0];
    switch (key) {
      case "hasTransform" :
      case "isAsync" :
      case "k" :
      case "of" :
      case "output" :
      case "p" :
      case "r" :
      case "seq" :
        return;
      default:
        if (typeof value === "function") {
          return;
        } else {
          if (typeof value === "object" && value !== null) {
            $$new[key] = cleanUpSchema(value);
          } else {
            $$new[key] = value;
          }
          return;
        }
    }
  });
  return $$new;
}

function unsafeAssertEqualSchemas(t, s1, s2, message) {
  t.deepEqual(cleanUpSchema(s1), cleanUpSchema(s2), message !== undefined ? Primitive_option.valFromOption(message) : undefined);
}

function assertCompiledCode(t, schema, op, code, message) {
  t.is(getCompiledCodeString(schema, op), code, message !== undefined ? Primitive_option.valFromOption(message) : undefined);
}

function assertCompiledCodeIsNoop(t, schema, op, message) {
  assertCompiledCode(t, schema, op, noopOpCode, message);
}

function assertReverseParsesBack(t, schema, value) {
  t.deepEqual(S.parseOrThrow(S.reverseConvertOrThrow(value, schema), schema), value);
}

function assertReverseReversesBack(t, schema) {
  unsafeAssertEqualSchemas(t, schema, S.reverse(S.reverse(schema)), undefined);
}

let assertEqualSchemas = unsafeAssertEqualSchemas;

export {
  noopOpCode,
  throwError,
  unsafeGetVariantPayload,
  Test,
  throwTestException,
  assertThrowsTestException,
  assertThrows,
  assertThrowsMessage,
  asyncAssertThrowsMessage,
  getCompiledCodeString,
  cleanUpSchema,
  unsafeAssertEqualSchemas,
  assertCompiledCode,
  assertCompiledCodeIsNoop,
  assertEqualSchemas,
  assertReverseParsesBack,
  assertReverseReversesBack,
}
/* noopOpCode Not a pure module */
