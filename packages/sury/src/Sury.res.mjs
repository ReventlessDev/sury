// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/Belt_List.js";
import * as JSONSchema from "./JSONSchema.res.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

let immutableEmpty = {};

let immutableEmpty$1 = [];

function capitalize(string) {
  return string.slice(0, 1).toUpperCase() + string.slice(1);
}

let copy = ((d) => ({...d}));

function fromString(string) {
  let _idx = 0;
  while (true) {
    let idx = _idx;
    let match = string[idx];
    if (match === undefined) {
      return "\"" + string + "\"";
    }
    switch (match) {
      case "\"" :
      case "\n" :
        return JSON.stringify(string);
      default:
        _idx = idx + 1 | 0;
        continue;
    }
  };
}

function toArray(path) {
  if (path === "") {
    return [];
  } else {
    return JSON.parse(path.split("\"][\"").join("\",\""));
  }
}

function fromLocation(location) {
  return "[" + fromString(location) + "]";
}

function fromArray(array) {
  let len = array.length;
  if (len !== 1) {
    if (len !== 0) {
      return array.map(fromLocation).join("");
    } else {
      return "";
    }
  } else {
    return "[" + fromString(array[0]) + "]";
  }
}

function concat(path, concatedPath) {
  return path + concatedPath;
}

let vendor = "sury";

let s = Symbol(vendor);

let itemSymbol = Symbol(vendor + ":item");

let stringTag = "string";

let numberTag = "number";

let bigintTag = "bigint";

let booleanTag = "boolean";

let symbolTag = "symbol";

let nullTag = "null";

let undefinedTag = "undefined";

let nanTag = "nan";

let instanceTag = "instance";

let arrayTag = "array";

let objectTag = "object";

let unionTag = "union";

let neverTag = "never";

let unknownTag = "unknown";

let refTag = "ref";

let Exn = /* @__PURE__ */Primitive_exceptions.create("Sury.Exn");

let constField = "const";

function isOptional(schema) {
  if (schema.type === undefinedTag) {
    return true;
  } else if (schema.type === unionTag) {
    return undefinedTag in schema.has;
  } else {
    return false;
  }
}

function has(acc, flag) {
  return (acc & flag) !== 0;
}

let flags = {
    [unknownTag]: 1,
    [stringTag]: 2,
    [numberTag]: 4,
    [booleanTag]: 8,
    [undefinedTag]: 16,
    [nullTag]: 32,
    [objectTag]: 64,
    [arrayTag]: 128,
    [unionTag]: 256,
    [refTag]: 512,
    [bigintTag]: 1024,
    [nanTag]: 2048,
    ["function"]: 4096,
    [instanceTag]: 8192,
    [neverTag]: 16384,
    [symbolTag]: 32768,
  };

function stringify(unknown) {
  let tagFlag = flags[typeof unknown];
  if (tagFlag & 16) {
    return undefinedTag;
  }
  if (!(tagFlag & 64)) {
    if (tagFlag & 2) {
      return "\"" + unknown + "\"";
    } else if (tagFlag & 1024) {
      return unknown + "n";
    } else if (tagFlag & 4096) {
      return "Function";
    } else {
      return unknown.toString();
    }
  }
  if (unknown === null) {
    return nullTag;
  }
  if (Array.isArray(unknown)) {
    let string = "[";
    for (let i = 0, i_finish = unknown.length; i < i_finish; ++i) {
      if (i !== 0) {
        string = string + ", ";
      }
      string = string + stringify(unknown[i]);
    }
    return string + "]";
  }
  if (unknown.constructor !== Object) {
    return Object.prototype.toString.call(unknown);
  }
  let keys = Object.keys(unknown);
  let string$1 = "{ ";
  for (let i$1 = 0, i_finish$1 = keys.length; i$1 < i_finish$1; ++i$1) {
    let key = keys[i$1];
    let value = unknown[key];
    string$1 = string$1 + key + ": " + stringify(value) + "; ";
  }
  return string$1 + "}";
}

function toExpression(schema) {
  let tag = schema.type;
  let $$const = schema.const;
  let name = schema.name;
  if (name !== undefined) {
    return name;
  }
  if ($$const !== undefined) {
    return stringify($$const);
  }
  let format = schema.format;
  let anyOf = schema.anyOf;
  if (anyOf !== undefined) {
    return anyOf.map(toExpression).join(" | ");
  }
  if (format !== undefined) {
    return format;
  }
  switch (tag) {
    case "nan" :
      return "NaN";
    case "object" :
      let additionalItems = schema.additionalItems;
      let properties = schema.properties;
      let locations = Object.keys(properties);
      if (locations.length === 0) {
        if (typeof additionalItems === objectTag) {
          return "{ [key: string]: " + toExpression(additionalItems) + "; }";
        } else {
          return "{}";
        }
      } else {
        return "{ " + locations.map(location => location + ": " + toExpression(properties[location]) + ";").join(" ") + " }";
      }
    default:
      if (schema.b) {
        return tag;
      }
      switch (tag) {
        case "instance" :
          return schema.class.name;
        case "array" :
          let additionalItems$1 = schema.additionalItems;
          let items = schema.items;
          if (typeof additionalItems$1 !== objectTag) {
            return "[" + items.map(toExpression).join(", ") + "]";
          }
          let itemName = toExpression(additionalItems$1);
          return (
            additionalItems$1.type === unionTag ? "(" + itemName + ")" : itemName
          ) + "[]";
        default:
          return tag;
      }
  }
}

class SuryError extends Error {
  constructor(params) {
    super();
    for (let key in params) {
      this[key] = params[key];
    }
  }
}

var d = Object.defineProperty, p = SuryError.prototype;
d(p, 'message', {
  get() {
      return message(this);
  },
})
d(p, 'name', {value: 'SuryError'})
d(p, 's', {value: s})
d(p, '_1', {
  get() {
    return this
  },
});
d(p, 'RE_EXN_ID', {
  value: Exn,
});

var seq = 1;
var Schema = function() {}, sp = Object.create(null);
d(sp, 'with', {
  get() {
    return (fn, ...args) => fn(this, ...args)
  },
});
// Also has ~standard below
Schema.prototype = sp;
;

function getOrRethrow(exn) {
  if ((exn&&exn.s===s)) {
    return exn;
  }
  throw exn;
}

function message(error) {
  let nonEmptyPath = error.path;
  let tmp = nonEmptyPath === "" ? "" : "Failed at " + nonEmptyPath + ": ";
  return tmp + error.reason;
}

let globalConfig = {
  m: message,
  d: undefined,
  a: "strip",
  f: 0
};

let valueOptions = {};

let configurableValueOptions = {configurable: true};

let valKey = "value";

let reverseKey = "r";

function base(tag, selfReverse) {
  let s = new Schema();
  s.type = tag;
  s.seq = (seq++);
  if (selfReverse) {
    valueOptions[valKey] = s;
    d(s, reverseKey, valueOptions);
  }
  return s;
}

let shakenRef = "as";

let shakenTraps = {
  get: (target, prop) => {
    let l = target[shakenRef];
    if (l === undefined) {
      return target[prop];
    }
    if (prop === shakenRef) {
      return target[prop];
    }
    let l$1 = Primitive_option.valFromOption(l);
    let message = "Schema S." + l$1 + " is not enabled. To start using it, add S.enable" + capitalize(l$1) + "() at the project root.";
    throw new Error("[Sury] " + message);
  }
};

function shaken(apiName) {
  let mut = base(neverTag, true);
  mut[shakenRef] = apiName;
  return new Proxy(mut, shakenTraps);
}

function noopDecoder(input, param) {
  return input;
}

let unknown = base(unknownTag, true);

unknown.decoder = noopDecoder;

let bool = base(booleanTag, true);

let symbol = base(symbolTag, true);

let string = base(stringTag, true);

let int = base(numberTag, true);

int.format = "int32";

let float = base(numberTag, true);

let bigint = base(bigintTag, true);

let unit = base(undefinedTag, true);

unit.const = (void 0);

let nullLiteral = base(nullTag, true);

nullLiteral.const = null;

let nan = base(nanTag, true);

nan.const = NaN;

let copySchema = ((schema) => {
  let c = new Schema()
  for (let k in schema) {
    c[k] = schema[k]
  }
  c.seq = seq++
  return c
});

function updateOutput(schema, fn) {
  let root = copySchema(schema);
  let mut = root;
  while (mut.to) {
    let next = copySchema(mut.to);
    mut.to = next;
    mut = next;
  };
  fn(mut);
  return root;
}

let $$class = SuryError;

function make(prim) {
  return new SuryError(prim);
}

let $$Error$1 = {
  $$class: $$class,
  make: make
};

function embed(b, value) {
  let e = b.g.e;
  let l = e.length;
  e[l] = value;
  return "e[" + l + "]";
}

function inlineConst(b, schema) {
  let tagFlag = flags[schema.type];
  let $$const = schema.const;
  if (tagFlag & 16) {
    return "void 0";
  } else if (tagFlag & 2) {
    return fromString($$const);
  } else if (tagFlag & 1024) {
    return $$const + "n";
  } else if (tagFlag & 45056) {
    return embed(b, schema.const);
  } else {
    return $$const;
  }
}

function inlineLocation(global, location) {
  let key = "\"" + location + "\"";
  let i = global[key];
  if (i !== undefined) {
    return i;
  }
  let inlinedLocation = fromString(location);
  global[key] = inlinedLocation;
  return inlinedLocation;
}

function secondAllocate(v) {
  let b = this;
  b.l = b.l + "," + v;
}

function initialAllocate(v) {
  let b = this;
  b.l = v;
  b.a = secondAllocate;
}

function _var() {
  return this.i;
}

function _bondVar() {
  let val = this;
  let bond = val.b;
  return bond.v();
}

function _prevVar() {
  let val = this;
  let prev = val.prev;
  return prev.v();
}

function varWithoutAllocation(global) {
  let newCounter = global.v + 1;
  global.v = newCounter;
  return "v" + newCounter;
}

function _notVarBeforeValidation() {
  let val = this;
  let v = varWithoutAllocation(val.g);
  val.cp = "let " + v + "=" + val.i + ";";
  val.i = v;
  val.v = _var;
  return v;
}

function _notVarAtParent() {
  let val = this;
  let v = varWithoutAllocation(val.g);
  val.p.a(v + "=" + val.i);
  val.v = _var;
  val.i = v;
  return v;
}

function _notVar() {
  let val = this;
  let v = varWithoutAllocation(val.g);
  let from = val.prev;
  let target = from !== undefined ? from : val;
  let i = val.i;
  if (i === "") {
    target.a(v);
  } else {
    target.a(v + "=" + i);
  }
  val.v = _var;
  val.i = v;
  return v;
}

function operationArg(schema, expected, flag, defs) {
  return {
    v: _var,
    i: "i",
    s: schema,
    e: expected,
    f: 0,
    c: "",
    cp: "",
    l: "",
    a: initialAllocate,
    validation: undefined,
    path: "",
    g: {
      v: -1,
      o: flag,
      e: [],
      d: defs
    }
  };
}

function failWithArg(b, fn, arg) {
  return embed(b, arg => {
    let errorDetails = fn(arg);
    throw new SuryError(errorDetails);
  }) + "(" + arg + ")";
}

function makeInvalidConversionDetails(input, to, cause) {
  if ((cause&&cause.s===s)) {
    if (!cause["p"]) {
      cause.path = input.path + cause.path;
    }
    return cause;
  }
  let tmp;
  if ((cause instanceof Error)) {
    let text = ("" + cause);
    tmp = text.startsWith("Error: ") ? text.slice(7) : text;
  } else {
    tmp = stringify(cause);
  }
  return {
    code: "invalid_conversion",
    path: input.path,
    reason: tmp,
    from: input.s,
    to: to,
    cause: cause
  };
}

function makeInvalidInputDetails(expected, received, path, input, includeInput, unionErrors) {
  let reasonRef = "Expected " + toExpression(expected) + ", received " + (
    includeInput ? stringify(input) : toExpression(received)
  );
  if (unionErrors !== undefined) {
    let reasonsDict = {};
    for (let idx = 0, idx_finish = unionErrors.length; idx < idx_finish; ++idx) {
      let caseError = unionErrors[idx];
      let caseReason = caseError.reason.split("\n").join("\n  ");
      let nonEmptyPath = caseError.path;
      let location = nonEmptyPath === "" ? "" : "At " + nonEmptyPath + ": ";
      let line = "\n- " + location + caseReason;
      if (!reasonsDict[line]) {
        reasonsDict[line] = 1;
        reasonRef = reasonRef + line;
      }
      
    }
  }
  let details = {
    code: "invalid_input",
    path: path,
    reason: reasonRef,
    expected: expected,
    received: received,
    unionErrors: unionErrors
  };
  if (includeInput) {
    details.input = input;
  }
  return details;
}

function embedInvalidInput(input, expectedOpt) {
  let expected = expectedOpt !== undefined ? expectedOpt : input.e;
  let received = input.s;
  return failWithArg(input, value => makeInvalidInputDetails(expected, received, input.path, value, true, undefined), input.v());
}

function merge(val) {
  let current = val;
  let code = "";
  while (current !== undefined) {
    let val$1 = current;
    current = val$1.prev;
    let currentCode = "";
    let validation = val$1.validation;
    if (validation !== undefined && val$1.e.noValidation !== true) {
      let input = current;
      let inputVar = input.v();
      let validationCode = validation(inputVar, true);
      currentCode = "if(" + validationCode + "){" + embedInvalidInput(input, val$1.e) + "}";
    }
    if (val$1.l !== "") {
      currentCode = currentCode + ("let " + val$1.l + ";");
    }
    ((delete val$1.a));
    currentCode = val$1.cp + currentCode + val$1.c;
    code = currentCode + code;
  };
  return code;
}

function appendValidation(validation1, validation2) {
  return (inputVar, negative) => (
    validation1 !== undefined ? validation1(inputVar, negative) + (
        negative ? "||" : "&&"
      ) : ""
  ) + validation2(inputVar, negative);
}

function next(prev, initial, schema, expectedOpt) {
  let expected = expectedOpt !== undefined ? expectedOpt : prev.e;
  return {
    v: _notVar,
    i: initial,
    s: schema,
    e: expected,
    prev: prev,
    f: 0,
    c: "",
    cp: "",
    l: "",
    a: initialAllocate,
    validation: undefined,
    t: true,
    path: prev.path,
    g: prev.g
  };
}

function refine(val, schemaOpt, validation, expectedOpt) {
  let schema = schemaOpt !== undefined ? schemaOpt : val.s;
  let expected = expectedOpt !== undefined ? expectedOpt : val.e;
  let shouldLink = val.v !== _var;
  let nextVal = {
    v: shouldLink ? _prevVar : _var,
    i: val.i,
    s: schema,
    e: expected,
    prev: val,
    f: val.f,
    d: val.d,
    c: "",
    cp: "",
    l: "",
    a: initialAllocate,
    validation: validation,
    t: val.t,
    path: val.path,
    g: val.g
  };
  if (shouldLink) {
    let valVar = (val.v.bind(val));
    val.v = () => {
      let v = valVar();
      nextVal.i = v;
      nextVal.v = _var;
      return v;
    };
  }
  return nextVal;
}

function dynamicScope(from, locationVar) {
  return {
    p: from,
    v: _notVarBeforeValidation,
    i: from.v() + "[" + locationVar + "]",
    s: from.s.additionalItems,
    e: from.e.additionalItems,
    f: from.f,
    c: "",
    cp: "",
    l: "",
    a: initialAllocate,
    validation: undefined,
    path: "",
    g: from.g
  };
}

function allocateVal(from, schema, expectedOpt) {
  let expected = expectedOpt !== undefined ? expectedOpt : from.e;
  let $$var = varWithoutAllocation(from.g);
  from.c = from.c + ("let " + $$var + ";");
  let v = next(from, $$var, schema, expected);
  v.v = _var;
  return v;
}

function nextConst(from, schema, expected) {
  return next(from, inlineConst(from, schema), schema, expected);
}

function asyncVal(from, initial) {
  let v = next(from, initial, unknown, undefined);
  v.f = 1;
  return v;
}

function objectJoin(inlinedLocation, value) {
  return inlinedLocation + ":" + value + ",";
}

function arrayJoin(_inlinedLocation, value) {
  return value + ",";
}

function add(objectVal, location, val) {
  if (objectVal.s.type === arrayTag) {
    objectVal.s.items.push(val.s);
  } else {
    objectVal.s.properties[location] = val.s;
  }
  objectVal.cp = objectVal.cp + merge(val);
  let inlinedLocation = inlineLocation(objectVal.g, location);
  objectVal.d[location] = val;
  if (val.f & 1) {
    objectVal.r = objectVal.r + val.i + ",";
    objectVal.i = objectVal.i + objectVal.j(inlinedLocation, "a[" + (objectVal.ac++) + "]");
  } else {
    objectVal.i = objectVal.i + objectVal.j(inlinedLocation, val.i);
  }
}

function complete(objectVal) {
  objectVal.i = objectVal.s.type === arrayTag ? "[" + objectVal.i + "]" : "{" + objectVal.i + "}";
  if (objectVal.ac) {
    objectVal.f = objectVal.f | 1;
    objectVal.i = "Promise.all([" + objectVal.r + "]).then(a=>(" + objectVal.i + "))";
  }
  return objectVal;
}

function addKey(objVal, key, value) {
  return objVal.v() + "[" + key + "]=" + value.i;
}

function scope(val) {
  let shouldLink = val.v !== _var;
  let newrecord = {...val};
  newrecord.t = false;
  newrecord.u = false;
  newrecord.validation = undefined;
  newrecord.a = initialAllocate;
  newrecord.l = "";
  newrecord.cp = "";
  newrecord.c = "";
  newrecord.k = false;
  newrecord.prev = undefined;
  newrecord.v = shouldLink ? _bondVar : _var;
  newrecord.b = val;
  if (shouldLink) {
    let valVar = (val.v.bind(val));
    val.v = () => {
      let v = valVar();
      newrecord.i = v;
      newrecord.v = _var;
      return v;
    };
  }
  return newrecord;
}

function get(parent, location) {
  let d = parent.d;
  let vals;
  if (d !== undefined) {
    vals = d;
  } else {
    let d$1 = {};
    parent.d = d$1;
    vals = d$1;
  }
  let v = vals[location];
  if (v !== undefined) {
    return scope(v);
  }
  let locationSchema = parent.s.type === objectTag ? parent.s.properties[location] : parent.s.items[location];
  let schema;
  if (locationSchema !== undefined) {
    schema = locationSchema;
  } else {
    let s = parent.s.additionalItems;
    if (s === "strip" || s === "strict") {
      if (s === "strip") {
        throw new Error("[Sury] The schema doesn't have additional items");
      }
      throw new Error("[Sury] The schema doesn't have additional items");
    } else {
      schema = s;
    }
  }
  let inlinedLocation = inlineLocation(parent.g, location);
  let pathAppend = "[" + inlinedLocation + "]";
  let item = next(parent, constField in schema ? inlineConst(parent, schema) : parent.v() + pathAppend, schema, undefined);
  item.t = false;
  item.prev = undefined;
  item.p = parent;
  item.path = parent.path + pathAppend;
  item.v = _notVarAtParent;
  vals[location] = item;
  return item;
}

function embedTransformation(input, fn, isAsync) {
  let output = allocateVal(input, unknown, undefined);
  output.t = true;
  if (isAsync) {
    if (!(input.g.o & 1)) {
      throw new SuryError({
        code: "invalid_operation",
        path: "",
        reason: "Encountered unexpected async transform or refine. Use parseAsyncOrThrow operation instead"
      });
    }
    output.f = output.f | 1;
  }
  let embededFn = embed(input, fn);
  let failure = failWithArg(output, e => makeInvalidConversionDetails(input, unknown, e), "x");
  output.c = "try{" + output.i + "=" + embededFn + "(" + input.i + ")" + (
    isAsync ? ".catch(x=>" + failure + ")" : ""
  ) + "}catch(x){" + failure + "}";
  return output;
}

function fail(b, message) {
  return embed(b, () => {
    throw new SuryError({
      code: "custom",
      path: b.path,
      reason: message
    });
  }) + "()";
}

function effectCtx(input) {
  return {
    fail: (message, pathOpt) => {
      let path = pathOpt !== undefined ? pathOpt : "";
      let error = new SuryError({
        code: "custom",
        path: input.path + path,
        reason: message
      });
      error["p"] = 1;
      throw error;
    }
  };
}

function invalidOperation(val, description) {
  throw new SuryError({
    code: "invalid_operation",
    path: val.path,
    reason: description
  });
}

function mergeWithPathPrepend(val, parent, locationVar, appendSafe) {
  if (val.path === "" && locationVar === undefined) {
    return merge(val);
  } else {
    let $$catch = errorVar => {
      let path = parent.path;
      let tmp = path === "" ? "" : fromString(path) + "+";
      return errorVar + ".path=" + tmp + (
        locationVar !== undefined ? "'[\"'+" + locationVar + "+'\"]'+" : ""
      ) + errorVar + ".path";
    };
    let valCode = merge(val);
    if (valCode === "" && !(val.f & 1)) {
      return valCode + (
        appendSafe !== undefined ? appendSafe() : ""
      );
    }
    let errorVar = varWithoutAllocation(val.g);
    let catchCode = $$catch(errorVar) + ";throw " + errorVar;
    if (val.f & 1) {
      val.i = val.i + ".catch(" + errorVar + "=>{" + catchCode + "})";
    }
    return "try{" + valCode + (
      appendSafe !== undefined ? appendSafe() : ""
    ) + "}catch(" + errorVar + "){" + catchCode + "}";
  }
}

function withPathPrepend(input, maybeDynamicLocationVar, appendSafe, fn) {
  return fn(input);
}

function unsupportedConversion(b, from, target) {
  let errorDetails_0 = b.path;
  let errorDetails_1 = "Unsupported conversion from " + toExpression(from) + " to " + toExpression(target);
  let errorDetails = {
    code: "unsupported_conversion",
    path: errorDetails_0,
    reason: errorDetails_1,
    from: from,
    to: target
  };
  throw new SuryError(errorDetails);
}

function noopOperation(i) {
  return i;
}

function inputToString(input) {
  return next(input, "\"\"+" + input.i, string, undefined);
}

function int32FormatValidation(inputVar, negative) {
  return inputVar + (
    negative ? ">" : "<"
  ) + "2147483647" + (
    negative ? "||" : "&&"
  ) + inputVar + (
    negative ? "<" : ">"
  ) + "-2147483648" + (
    negative ? "||" : "&&"
  ) + inputVar + "%1" + (
    negative ? "!==" : "==="
  ) + "0";
}

function numberDecoder(input, param) {
  let inputTagFlag = flags[input.s.type];
  if (inputTagFlag & 1) {
    return refine(input, input.e, (inputVar, negative) => {
      let match = input.e.format;
      let tmp;
      let exit = 0;
      if (match !== undefined) {
        switch (match) {
          case "int32" :
            tmp = (
              negative ? "||" : "&&"
            ) + int32FormatValidation(inputVar, negative);
            break;
          case "port" :
          case "json" :
            exit = 1;
            break;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        tmp = input.g.o & 2 ? "" : (
            negative ? "||" : "&&"
          ) + (
            negative ? "" : "!"
          ) + "Number.isNaN(" + inputVar + ")";
      }
      return "typeof " + inputVar + (
        negative ? "!==" : "==="
      ) + "\"" + numberTag + "\"" + tmp;
    }, undefined);
  }
  if (!(inputTagFlag & 2)) {
    if (inputTagFlag & 4) {
      if (input.s.format !== input.e.format && input.e.format === "int32") {
        return refine(input, input.e, int32FormatValidation, undefined);
      } else {
        return input;
      }
    } else {
      return unsupportedConversion(input, input.s, input.e);
    }
  }
  let outputVar = varWithoutAllocation(input.g);
  input.a(outputVar + "=+" + input.v());
  let output = next(input, outputVar, input.e, undefined);
  output.v = _var;
  output.validation = (param, negative) => {
    let match = input.e.format;
    if (match !== undefined) {
      switch (match) {
        case "int32" :
          return int32FormatValidation(outputVar, negative);
        case "port" :
        case "json" :
          break;
      }
    }
    return (
      negative ? "" : "!"
    ) + "Number.isNaN(" + outputVar + ")";
  };
  return output;
}

float.decoder = numberDecoder;

int.decoder = numberDecoder;

function stringDecoder(input, param) {
  let inputTagFlag = flags[input.s.type];
  if (inputTagFlag & 1) {
    return refine(input, input.e, (inputVar, negative) => "typeof " + inputVar + (
      negative ? "!==" : "==="
    ) + "\"" + stringTag + "\"", undefined);
  }
  if (!(inputTagFlag & 3132 && constField in input.s)) {
    if (inputTagFlag & 1036) {
      return inputToString(input);
    } else if (inputTagFlag & 2) {
      return input;
    } else {
      return unsupportedConversion(input, input.s, input.e);
    }
  }
  let $$const = (""+input.s.const);
  let schema = base(stringTag, false);
  schema.const = $$const;
  return next(input, "\"" + $$const + "\"", schema, undefined);
}

string.decoder = stringDecoder;

function booleanDecoder(input, param) {
  let inputTagFlag = flags[input.s.type];
  if (inputTagFlag & 1) {
    return refine(input, input.e, (inputVar, negative) => "typeof " + inputVar + (
      negative ? "!==" : "==="
    ) + "\"" + booleanTag + "\"", undefined);
  }
  if (!(inputTagFlag & 2)) {
    if (inputTagFlag & 8) {
      return input;
    } else {
      return unsupportedConversion(input, input.s, input.e);
    }
  }
  let outputVar = varWithoutAllocation(input.g);
  input.a(outputVar);
  let output = next(input, outputVar, input.e, undefined);
  output.v = _var;
  let inputVar = input.v();
  output.cp = "(" + output.i + "=" + inputVar + "===\"true\")||" + inputVar + "===\"false\"||" + embedInvalidInput(input, undefined) + ";";
  return output;
}

bool.decoder = booleanDecoder;

function bigintDecoder(input, param) {
  let inputTagFlag = flags[input.s.type];
  if (inputTagFlag & 1) {
    return refine(input, input.e, (inputVar, negative) => "typeof " + inputVar + (
      negative ? "!==" : "==="
    ) + "\"" + bigintTag + "\"", undefined);
  }
  if (!(inputTagFlag & 2)) {
    if (inputTagFlag & 4) {
      return next(input, "BigInt(" + input.i + ")", input.e, undefined);
    } else if (inputTagFlag & 1024) {
      return input;
    } else {
      return unsupportedConversion(input, input.s, input.e);
    }
  }
  let outputVar = varWithoutAllocation(input.g);
  input.a(outputVar);
  let output = next(input, outputVar, input.e, undefined);
  output.v = _var;
  output.cp = "try{" + outputVar + "=BigInt(" + input.v() + ")}catch(_){" + embedInvalidInput(input, undefined) + "}";
  return output;
}

bigint.decoder = bigintDecoder;

function symbolDecoder(input, param) {
  let inputTagFlag = flags[input.s.type];
  if (inputTagFlag & 1) {
    return refine(input, input.e, (inputVar, negative) => "typeof " + inputVar + (
      negative ? "!==" : "==="
    ) + "\"" + symbolTag + "\"", undefined);
  } else if (inputTagFlag & 32768) {
    return input;
  } else {
    return unsupportedConversion(input, input.s, input.e);
  }
}

symbol.decoder = symbolDecoder;

function setHas(has, tag) {
  has[flags[tag] & 768 ? unknownTag : tag] = true;
}

let jsonName = "JSON";

let jsonString = shaken("jsonString");

function jsonStringWithSpace(space) {
  let mut = copySchema(jsonString);
  mut.space = space;
  return mut;
}

let json = shaken("json");

function literalDecoder(input, param) {
  let expectedSchema = input.e;
  if (expectedSchema.noValidation) {
    return nextConst(input, expectedSchema, undefined);
  }
  if (constField in input.s) {
    if (input.s.const === expectedSchema.const) {
      return input;
    } else {
      return nextConst(input, expectedSchema, undefined);
    }
  }
  let schemaTagFlag = flags[expectedSchema.type];
  if (!(flags[input.s.type] & 2 && schemaTagFlag & 3132)) {
    if (schemaTagFlag & 2048) {
      return refine(input, expectedSchema, (inputVar, negative) => (
        negative ? "!" : ""
      ) + "Number.isNaN(" + inputVar + ")", undefined);
    } else {
      return refine(input, expectedSchema, (inputVar, negative) => inputVar + (
        negative ? "!==" : "==="
      ) + inlineConst(input, expectedSchema), undefined);
    }
  }
  let stringConstSchema = base(stringTag, true);
  stringConstSchema.const = ("" + expectedSchema.const);
  stringConstSchema.to = expectedSchema;
  let stringConstVal = nextConst(input, stringConstSchema, stringConstSchema);
  stringConstVal.validation = (inputVar, negative) => inputVar + (
    negative ? "!==" : "==="
  ) + "\"" + stringConstSchema.const + "\"";
  return nextConst(stringConstVal, expectedSchema, undefined);
}

nullLiteral.decoder = literalDecoder;

unit.decoder = literalDecoder;

nan.decoder = literalDecoder;

function parse(value) {
  if (value === null) {
    return nullLiteral;
  }
  let $$typeof = typeof value;
  if ($$typeof === "object") {
    let s = base(instanceTag, true);
    s.class = value.constructor;
    s.const = value;
    s.decoder = literalDecoder;
    return s;
  }
  if ($$typeof === "undefined") {
    return unit;
  }
  if ($$typeof === "number" && Number.isNaN(value)) {
    return nan;
  }
  let s$1 = base($$typeof, true);
  s$1.const = value;
  s$1.decoder = literalDecoder;
  return s$1;
}

function parse$1(input, withEncoderOpt) {
  let withEncoder = withEncoderOpt !== undefined ? withEncoderOpt : false;
  let expected = input.e;
  if (input.e.$defs) {
    if (input.g.d) {
      Object.assign(input.g.d, input.e.$defs);
    } else {
      input.g.d = input.e.$defs;
    }
  }
  if (input.f & 1) {
    let operationInputVar = input.v();
    let operationInput = next(input, operationInputVar, input.s, input.e);
    operationInput.v = _var;
    operationInput.prev = undefined;
    let operationOutput = parse$1(operationInput, undefined);
    let operationCode = merge(operationOutput);
    if (operationInput.i !== operationOutput.i || operationCode !== "") {
      input.i = input.i + ".then(" + operationInputVar + "=>{" + operationCode + "return " + operationOutput.i + "})";
    }
    input.s = operationOutput.s;
    input.e = operationOutput.e;
    return input;
  }
  let output = input;
  let encoder = output.s.encoder;
  if (encoder !== undefined && withEncoder && output.s !== output.e && output.e.type !== unknownTag) {
    output = encoder(output, output.e);
  }
  if (output.k !== true) {
    output = expected.decoder(output, expected);
    let inputRefiner = expected.inputRefiner;
    if (inputRefiner !== undefined) {
      output = inputRefiner(output, expected);
    }
    let refiner = expected.refiner;
    if (refiner !== undefined) {
      output = refiner(output, expected);
    }
    let to = output.e.to;
    if (to !== undefined) {
      let match = output.e;
      let parser = match.parser;
      if (parser !== undefined) {
        output = parser(output, output.e);
      } else {
        let encoder$1 = output.s.encoder;
        if (encoder$1 !== undefined && to.type !== unknownTag) {
          output = encoder$1(output, to);
        }
        
      }
      if (output.k !== true) {
        output = parse$1(refine(output, undefined, undefined, to), undefined);
      }
      
    }
    
  }
  return output;
}

function getOutputSchema(_schema) {
  while (true) {
    let schema = _schema;
    let to = schema.to;
    if (to === undefined) {
      return schema;
    }
    _schema = to;
    continue;
  };
}

function reverse(schema) {
  if (reverseKey in schema) {
    return schema[reverseKey];
  }
  let reversedHead;
  let current = schema;
  while (current) {
    let mut = copySchema(current);
    let next = mut.to;
    let to = reversedHead;
    if (to !== undefined) {
      mut.to = to;
    } else {
      ((delete mut.to));
    }
    let parser = mut.parser;
    let serializer = mut.serializer;
    if (serializer !== undefined) {
      mut.parser = serializer;
    } else {
      ((delete mut.parser));
    }
    if (parser !== undefined) {
      mut.serializer = parser;
    } else {
      ((delete mut.serializer));
    }
    let refiner = mut.refiner;
    let inputRefiner = mut.inputRefiner;
    if (inputRefiner !== undefined) {
      mut.refiner = inputRefiner;
    } else {
      ((delete mut.refiner));
    }
    if (refiner !== undefined) {
      mut.inputRefiner = refiner;
    } else {
      ((delete mut.inputRefiner));
    }
    let fromDefault = mut.fromDefault;
    let $$default = mut.default;
    if ($$default !== undefined) {
      mut.fromDefault = $$default;
    } else {
      ((delete mut.fromDefault));
    }
    if (fromDefault !== undefined) {
      mut.default = fromDefault;
    } else {
      ((delete mut.default));
    }
    let items = mut.items;
    if (items !== undefined) {
      let newItems = new Array(items.length);
      for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
        newItems[idx] = reverse(items[idx]);
      }
      mut.items = newItems;
    }
    let properties = mut.properties;
    if (properties !== undefined) {
      let newProperties = {};
      let keys = Object.keys(properties);
      for (let idx$1 = 0, idx_finish$1 = keys.length; idx$1 < idx_finish$1; ++idx$1) {
        let key = keys[idx$1];
        newProperties[key] = reverse(properties[key]);
      }
      mut.properties = newProperties;
    }
    if (typeof mut.additionalItems === "object") {
      mut.additionalItems = reverse(mut.additionalItems);
    }
    let anyOf = mut.anyOf;
    if (anyOf !== undefined) {
      let has = {};
      let newAnyOf = [];
      for (let idx$2 = 0, idx_finish$2 = anyOf.length; idx$2 < idx_finish$2; ++idx$2) {
        let s = anyOf[idx$2];
        let reversed = reverse(s);
        newAnyOf.push(reversed);
        setHas(has, reversed.type);
      }
      mut.has = has;
      mut.anyOf = newAnyOf;
    }
    let defs = mut.$defs;
    if (defs !== undefined) {
      let reversedDefs = {};
      for (let idx$3 = 0, idx_finish$3 = Object.keys(defs).length; idx$3 < idx_finish$3; ++idx$3) {
        let key$1 = Object.keys(defs)[idx$3];
        reversedDefs[key$1] = reverse(defs[key$1]);
      }
      mut.$defs = reversedDefs;
    }
    reversedHead = mut;
    current = next;
  };
  let r = reversedHead;
  valueOptions[valKey] = r;
  d(schema, reverseKey, valueOptions);
  valueOptions[valKey] = schema;
  d(r, reverseKey, valueOptions);
  return r;
}

function parseDynamic(input) {
  try {
    return parse$1(input, true);
  } catch (exn) {
    let error = getOrRethrow(exn);
    let p = input.p;
    error.path = (
      p !== undefined ? p.path : ""
    ) + (input.path + "[]" + error.path);
    throw error;
  }
}

function isAsyncInternal(schema, defs) {
  try {
    let input = operationArg(unknown, schema, 1, defs);
    let output = parse$1(input, undefined);
    let isAsync = has(output.f, 1);
    schema.isAsync = isAsync;
    return isAsync;
  } catch (exn) {
    getOrRethrow(exn);
    return false;
  }
}

function compileDecoder(schema, expected, flag, defs) {
  let input = operationArg(constField in schema ? unknown : schema, expected, flag, defs);
  let output = parse$1(input, true);
  let code = merge(output);
  let isAsync = has(output.f, 1);
  expected.isAsync = isAsync;
  if (code === "" && (output === input || output.i === input.i) && !(flag & 1)) {
    return noopOperation;
  }
  let inlinedOutput = output.i;
  if (flag & 1 && !isAsync && !defs) {
    inlinedOutput = "Promise.resolve(" + inlinedOutput + ")";
  }
  let inlinedFunction = "i=>{" + code + "return " + inlinedOutput + "}";
  let ctxVarValue1 = input.g.e;
  return new Function("e", "s", "return " + inlinedFunction)(ctxVarValue1, s);
}

function getDecoder(param, param$1) {
  let args = arguments;
  let idx = 0;
  let flag;
  let keyRef = "";
  let maxSeq = 0;
  let cacheTarget;
  while (flag === undefined) {
    let arg = args[idx];
    if (arg) {
      if (typeof arg === "number") {
        let f = arg | globalConfig.f;
        flag = f;
        keyRef = keyRef + "-" + f;
      } else {
        let seq = arg.seq;
        if (seq > maxSeq) {
          maxSeq = seq;
          cacheTarget = arg;
        }
        keyRef = keyRef + seq + "-";
        idx = idx + 1 | 0;
      }
    } else {
      let f$1 = globalConfig.f;
      flag = f$1;
      keyRef = keyRef + "-" + f$1;
    }
  };
  let cacheTarget$1 = cacheTarget;
  if (cacheTarget$1 !== undefined) {
    let key = keyRef;
    if (key in cacheTarget$1) {
      return cacheTarget$1[key];
    }
    let schema = args[idx - 1 | 0];
    for (let i = idx - 2 | 0; i >= 0; --i) {
      let to = schema;
      schema = updateOutput(args[i], mut => {
        mut.to = to;
      });
    }
    let f$2 = compileDecoder(schema, schema, flag, 0);
    valueOptions[valKey] = f$2;
    d(cacheTarget$1, key, valueOptions);
    return f$2;
  }
  throw new Error("[Sury] No schema provided for decoder.");
}

function makeObjectVal(prev, schema) {
  return {
    v: _notVar,
    i: "",
    s: schema.type === arrayTag ? ({
        type: arrayTag,
        decoder: arrayDecoder,
        additionalItems: "strict",
        items: []
      }) : ({
        type: objectTag,
        decoder: objectDecoder,
        additionalItems: "strict",
        properties: {}
      }),
    e: prev.e,
    prev: prev,
    f: 0,
    d: {},
    c: "",
    cp: "",
    l: "",
    a: initialAllocate,
    validation: undefined,
    t: true,
    path: prev.path,
    g: prev.g,
    j: schema.type === arrayTag ? arrayJoin : objectJoin,
    ac: 0,
    r: ""
  };
}

function array(item) {
  let mut = base(arrayTag, false);
  mut.additionalItems = item;
  mut.items = immutableEmpty$1;
  mut.decoder = arrayDecoder;
  return mut;
}

function arrayDecoder(unknownInput, param) {
  let isUnion = unknownInput.u;
  let expectedSchema = unknownInput.e;
  let unknownInputTagFlag = flags[unknownInput.s.type];
  let expectedItems = expectedSchema.items;
  let expectedLength = expectedItems.length;
  let input;
  if (unknownInputTagFlag & 129) {
    let validation;
    let isArrayInput = unknownInputTagFlag & 128;
    let schema;
    if (isArrayInput) {
      schema = unknownInput.s;
    } else {
      validation = (inputVar, negative) => (
        negative ? "!" : ""
      ) + "Array.isArray(" + inputVar + ")";
      schema = array(unknown);
    }
    let match = schema.additionalItems;
    let isExactSize;
    isExactSize = match === "strip" || match === "strict" ? schema.items.length === expectedLength : false;
    if (!isExactSize) {
      let match$1 = expectedSchema.additionalItems;
      if (match$1 === "strip" || match$1 === "strict") {
        validation = match$1 === "strip" ? appendValidation(validation, (inputVar, negative) => inputVar + ".length" + (
            negative ? "<" : ">"
          ) + expectedLength) : appendValidation(validation, (inputVar, negative) => inputVar + ".length" + (
            negative ? "!==" : "==="
          ) + expectedLength);
      }
      
    }
    let validation$1 = validation;
    input = validation$1 !== undefined ? refine(unknownInput, schema, validation$1, undefined) : refine(unknownInput, undefined, undefined, undefined);
  } else {
    input = unsupportedConversion(unknownInput, unknownInput.s, expectedSchema);
  }
  let itemSchema = expectedSchema.additionalItems;
  if (itemSchema === "strip" || itemSchema === "strict") {
    itemSchema === "strip";
  } else {
    if (itemSchema === unknown) {
      return input;
    }
    let inputVar = input.v();
    let iteratorVar = varWithoutAllocation(input.g);
    let itemInput = dynamicScope(input, iteratorVar);
    let itemOutput = parseDynamic(itemInput);
    let hasTransform = itemOutput.t;
    let output = hasTransform ? next(input, "new Array(" + inputVar + ".length)", expectedSchema, undefined) : refine(input, expectedSchema, undefined, undefined);
    let itemCode = mergeWithPathPrepend(itemOutput, input, iteratorVar, hasTransform ? () => addKey(output, iteratorVar, itemOutput) : undefined);
    if (hasTransform || itemCode !== "") {
      output.cp = output.cp + ("for(let " + iteratorVar + "=" + expectedLength + ";" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + itemCode + "}");
    }
    if (itemOutput.f & 1) {
      return asyncVal(output, "Promise.all(" + output.i + ")");
    } else {
      return output;
    }
  }
  let objectVal = makeObjectVal(input, expectedSchema);
  let match$2 = expectedSchema.additionalItems;
  let shouldRecreateInput;
  if (match$2 === "strip" || match$2 === "strict") {
    if (match$2 === "strip") {
      let match$3 = input.s.additionalItems;
      shouldRecreateInput = match$3 === "strip" || match$3 === "strict" ? input.s.items.length !== expectedLength : true;
    } else {
      shouldRecreateInput = false;
    }
  } else {
    shouldRecreateInput = true;
  }
  for (let idx = 0; idx < expectedLength; ++idx) {
    let schema$1 = expectedItems[idx];
    let key = idx.toString();
    let itemInput$1 = get(input, key);
    itemInput$1.e = schema$1;
    itemInput$1.u = isUnion;
    let itemOutput$1 = parse$1(itemInput$1, true);
    let validation$2 = itemOutput$1.validation;
    if (validation$2 !== undefined && isUnion && constField in schema$1) {
      input.validation = appendValidation(input.validation, (inputVar, negative) => {
        let inlinedLocation = inlineLocation(input.g, key);
        return validation$2(inputVar + ("[" + inlinedLocation + "]"), negative);
      });
      itemOutput$1.validation = undefined;
    }
    add(objectVal, key, itemOutput$1);
    if (!shouldRecreateInput) {
      shouldRecreateInput = itemOutput$1.t;
    }
    
  }
  if (shouldRecreateInput) {
    return complete(objectVal);
  }
  let o = refine(input, undefined, undefined, undefined);
  o.cp = objectVal.cp;
  o.d = objectVal.d;
  return o;
}

function objectDecoder(unknownInput, param) {
  let isUnion = unknownInput.u;
  let expectedSchema = unknownInput.e;
  let unknownInputTagFlag = flags[unknownInput.s.type];
  let input;
  if (unknownInputTagFlag & 65) {
    let validation;
    let isObjectInput = unknownInputTagFlag & 64;
    let schema;
    if (isObjectInput) {
      schema = unknownInput.s;
    } else {
      validation = (inputVar, negative) => "typeof " + inputVar + (
        negative ? "!==" : "==="
      ) + "\"" + objectTag + "\"" + (
        negative ? "||" : "&&"
      ) + (
        negative ? "!" : ""
      ) + inputVar;
      let mut = base(objectTag, false);
      mut.properties = immutableEmpty;
      mut.additionalItems = unknown;
      schema = mut;
    }
    if (!isObjectInput && expectedSchema.additionalItems !== "strip") {
      validation = appendValidation(validation, (inputVar, negative) => (
        negative ? "" : "!"
      ) + "Array.isArray(" + inputVar + ")");
    }
    let validation$1 = validation;
    input = validation$1 !== undefined ? refine(unknownInput, schema, validation$1, undefined) : refine(unknownInput, undefined, undefined, undefined);
  } else {
    input = unsupportedConversion(unknownInput, unknownInput.s, expectedSchema);
  }
  let itemSchema = expectedSchema.additionalItems;
  let exit = 0;
  if (itemSchema === "strip" || itemSchema === "strict") {
    exit = 1;
  } else {
    if (itemSchema === unknown) {
      return input;
    }
    let inputVar = input.v();
    let keyVar = varWithoutAllocation(input.g);
    let itemInput = dynamicScope(input, keyVar);
    let itemOutput = parseDynamic(itemInput);
    let hasTransform = itemOutput.t;
    let output = hasTransform ? next(input, "{}", expectedSchema, undefined) : refine(input, expectedSchema, undefined, undefined);
    let itemCode = mergeWithPathPrepend(itemOutput, input, keyVar, hasTransform ? () => addKey(output, keyVar, itemOutput) : undefined);
    if (hasTransform || itemCode !== "") {
      output.cp = output.cp + ("for(let " + keyVar + " in " + inputVar + "){" + itemCode + "}");
    }
    if (!(itemOutput.f & 1)) {
      return output;
    }
    let resolveVar = varWithoutAllocation(output.g);
    let rejectVar = varWithoutAllocation(output.g);
    let asyncParseResultVar = varWithoutAllocation(output.g);
    let counterVar = varWithoutAllocation(output.g);
    let outputVar = output.v();
    return asyncVal(output, "new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=Object.keys(" + outputVar + ").length;for(let " + keyVar + " in " + outputVar + "){" + outputVar + "[" + keyVar + "].then(" + asyncParseResultVar + "=>{" + outputVar + "[" + keyVar + "]=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + outputVar + ")}}," + rejectVar + ")}})");
  }
  if (exit === 1) {
    let properties = expectedSchema.properties;
    let keys = Object.keys(properties);
    let keysCount = keys.length;
    let objectVal = makeObjectVal(input, expectedSchema);
    let match = expectedSchema.additionalItems;
    let shouldRecreateInput;
    if (match === "strip" || match === "strict") {
      if (match === "strip") {
        let match$1 = input.s.additionalItems;
        let exit$1 = 0;
        if (match$1 === "strip" || match$1 === "strict") {
          exit$1 = 2;
        } else {
          shouldRecreateInput = true;
        }
        if (exit$1 === 2) {
          shouldRecreateInput = Object.keys(input.s.properties).length !== keysCount;
        }
        
      } else {
        shouldRecreateInput = false;
      }
    } else {
      shouldRecreateInput = true;
    }
    for (let idx = 0; idx < keysCount; ++idx) {
      let key = keys[idx];
      let schema$1 = properties[key];
      let itemInput$1 = get(input, key);
      itemInput$1.e = schema$1;
      itemInput$1.u = isUnion;
      let itemOutput$1 = parse$1(itemInput$1, true);
      let validation$2 = itemOutput$1.validation;
      if (validation$2 !== undefined && isUnion && constField in schema$1) {
        input.validation = appendValidation(input.validation, (inputVar, negative) => {
          let inlinedLocation = inlineLocation(input.g, key);
          return validation$2(inputVar + ("[" + inlinedLocation + "]"), negative);
        });
        itemOutput$1.validation = undefined;
      }
      add(objectVal, key, itemOutput$1);
      if (!shouldRecreateInput) {
        shouldRecreateInput = itemOutput$1.t;
      }
      
    }
    let tmp = false;
    if (expectedSchema.additionalItems === "strict") {
      let match$2 = input.s.additionalItems;
      let tmp$1;
      tmp$1 = match$2 !== "strip" && match$2 !== "strict";
      tmp = tmp$1;
    }
    if (tmp) {
      let keyVar$1 = varWithoutAllocation(objectVal.g);
      input.a(keyVar$1);
      objectVal.cp = objectVal.cp + ("for(" + keyVar$1 + " in " + input.v() + "){if(");
      if (keys.length !== 0) {
        for (let idx$1 = 0, idx_finish = keys.length; idx$1 < idx_finish; ++idx$1) {
          let key$1 = keys[idx$1];
          if (idx$1 !== 0) {
            objectVal.cp = objectVal.cp + "&&";
          }
          objectVal.cp = objectVal.cp + (keyVar$1 + "!==" + inlineLocation(input.g, key$1));
        }
      } else {
        objectVal.cp = objectVal.cp + "true";
      }
      objectVal.cp = objectVal.cp + ("){" + failWithArg(input, exccessFieldName => ({
        code: "unrecognized_keys",
        path: objectVal.path,
        reason: "Unrecognized key \"" + exccessFieldName + "\"",
        keys: [exccessFieldName]
      }), keyVar$1) + "}}");
    }
    if (shouldRecreateInput) {
      return complete(objectVal);
    }
    let o = refine(input, undefined, undefined, undefined);
    o.cp = objectVal.cp;
    o.d = objectVal.d;
    return o;
  }
  
}

function recursiveDecoder(input, param) {
  let expectedSchema = input.e;
  let ref = expectedSchema.$ref;
  let defs = input.g.d;
  let identifier = ref.slice(8);
  let def = defs[identifier];
  let flag = input.g.o;
  let inputSchema = input.s.seq === expectedSchema.seq ? def : input.s;
  let key = inputSchema.seq + "-" + def.seq + "--" + flag;
  let fn = def[key];
  let recOperation;
  if (fn !== undefined) {
    let fn$1 = Primitive_option.valFromOption(fn);
    recOperation = fn$1 === 0 ? embed(input, def) + ("[\"" + key + "\"]") : embed(input, fn$1);
  } else {
    configurableValueOptions[valKey] = 0;
    d(def, key, configurableValueOptions);
    let fn$2 = compileDecoder(inputSchema, def, flag, defs);
    valueOptions[valKey] = fn$2;
    d(def, key, valueOptions);
    recOperation = embed(input, fn$2);
  }
  let outputVar = varWithoutAllocation(input.g);
  input.a(outputVar);
  let output = next(input, outputVar, expectedSchema, expectedSchema);
  output.v = _var;
  output.prev = undefined;
  output.cp = outputVar + "=" + recOperation + "(" + input.i + ");";
  if (def.isAsync === undefined) {
    let defsMut = copy(defs);
    defsMut[identifier] = unknown;
    isAsyncInternal(def, defsMut);
  }
  if (def.isAsync) {
    output.f = output.f | 1;
  }
  output.cp = mergeWithPathPrepend(output, input, undefined, undefined);
  output.prev = input;
  return output;
}

function instanceDecoder(input, param) {
  let inputTagFlag = flags[input.s.type];
  if (inputTagFlag & 1) {
    return refine(input, input.e, (inputVar, negative) => {
      let c = inputVar + " instanceof " + embed(input, input.e.class);
      if (negative) {
        return "!(" + c + ")";
      } else {
        return c;
      }
    }, undefined);
  } else if (inputTagFlag & 8192 && input.s.class === input.e.class) {
    return input;
  } else {
    return unsupportedConversion(input, input.s, input.e);
  }
}

function instance(class_) {
  let mut = base(instanceTag, true);
  mut.class = class_;
  mut.decoder = instanceDecoder;
  return mut;
}

d(sp, "~standard", {
  get: function () {
    let schema = this;
    return {
      version: 1,
      vendor: vendor,
      validate: input => {
        try {
          return {
            value: getDecoder(unknown, schema)(input)
          };
        } catch (exn) {
          let error = getOrRethrow(exn);
          return {
            issues: [{
                message: error.reason,
                path: error.path === "" ? undefined : toArray(error.path)
              }]
          };
        }
      }
    };
  }
});

function makeConvertOrThrow(from, to, flag) {
  return getDecoder(reverse(from), to, flag !== undefined ? Primitive_option.valFromOption(flag) : undefined);
}

function makeAsyncConvertOrThrow(from, to, flagOpt) {
  let flag = flagOpt !== undefined ? flagOpt : 0;
  return getDecoder(reverse(from), to, flag | 1);
}

function parseOrThrow(any, schema) {
  return getDecoder(unknown, schema)(any);
}

function parseJsonOrThrow(any, schema) {
  return getDecoder(json, schema)(any);
}

function parseJsonStringOrThrow(any, schema) {
  return getDecoder(jsonString, schema)(any);
}

function parseAsyncOrThrow(any, schema) {
  return getDecoder(unknown, schema, 1)(any);
}

function convertOrThrow(input, schema) {
  return getDecoder(schema, undefined)(input);
}

function convertToJsonOrThrow(input, schema) {
  return getDecoder(schema, json)(input);
}

function convertToJsonStringOrThrow(input, schema) {
  return getDecoder(schema, jsonString)(input);
}

function convertAsyncOrThrow(input, schema) {
  return getDecoder(schema, 1)(input);
}

function reverseConvertOrThrow(value, schema) {
  return getDecoder(reverse(schema), undefined)(value);
}

function reverseConvertToJsonOrThrow(value, schema) {
  return getDecoder(reverse(schema), json)(value);
}

function reverseConvertToJsonStringOrThrow(value, schema, space) {
  return getDecoder(reverse(schema), space !== undefined && space !== 0 ? jsonStringWithSpace(space) : jsonString)(value);
}

let assertResult = copySchema(unit);

assertResult.noValidation = true;

function assertOrThrow(any, schema) {
  return getDecoder(unknown, schema, assertResult)(any);
}

function isAsync(schema) {
  let v = schema.isAsync;
  if (v !== undefined) {
    return v;
  } else {
    return isAsyncInternal(schema, 0);
  }
}

function wrapExnToFailure(exn) {
  if ((exn&&exn.s===s)) {
    return {
      success: false,
      error: exn
    };
  }
  throw exn;
}

function js_safe(fn) {
  try {
    return {
      success: true,
      value: fn()
    };
  } catch (exn) {
    return wrapExnToFailure(exn);
  }
}

function js_safeAsync(fn) {
  try {
    return fn().then(value => ({
      success: true,
      value: value
    }), wrapExnToFailure);
  } catch (exn) {
    return Promise.resolve(wrapExnToFailure(exn));
  }
}

function make$1(namespace, name) {
  return "m:" + namespace + ":" + name;
}

function internal(name) {
  return "m:" + name;
}

let Id = {
  make: make$1,
  internal: internal
};

function get$1(schema, id) {
  return schema[id];
}

function set(schema, id, metadata) {
  let mut = copySchema(schema);
  mut[id] = metadata;
  return mut;
}

let defsPath = "#/$defs/";

function recursive(name, fn) {
  let ref = defsPath + name;
  let refSchema = base(refTag, true);
  refSchema.$ref = ref;
  refSchema.name = name;
  refSchema.decoder = recursiveDecoder;
  let isNestedRec = globalConfig.d;
  if (!isNestedRec) {
    globalConfig.d = {};
  }
  let def = fn(refSchema);
  if (def.name) {
    refSchema.name = def.name;
  } else {
    def.name = name;
  }
  globalConfig.d[name] = def;
  if (isNestedRec) {
    return refSchema;
  }
  let schema = base(refTag, true);
  schema.name = def.name;
  schema.$ref = ref;
  schema.$defs = globalConfig.d;
  schema.decoder = recursiveDecoder;
  globalConfig.d = undefined;
  return schema;
}

function noValidation(schema, value) {
  let mut = copySchema(schema);
  mut.noValidation = value;
  return mut;
}

function appendRefiner(existingDecoder, refiner) {
  return (input, selfSchema) => {
    let output = existingDecoder(input, selfSchema);
    output.c = output.c + refiner(output, selfSchema);
    return output;
  };
}

function internalRefine(schema, refiner) {
  return updateOutput(schema, mut => {
    mut.decoder = appendRefiner(mut.decoder, refiner(mut));
  });
}

function refine$1(schema, refiner) {
  return internalRefine(schema, param => ((input, param) => embed(input, refiner(effectCtx(input))) + "(" + input.v() + ");"));
}

function addRefinement(schema, metadataId, refinement, refiner) {
  return internalRefine(schema, mut => {
    let refinements = schema[metadataId];
    let metadata = refinements !== undefined ? refinements.concat(refinement) : [refinement];
    mut[metadataId] = metadata;
    return refiner;
  });
}

function transform(schema, transformer) {
  return updateOutput(schema, mut => {
    mut.parser = (input, param) => {
      let match = transformer(effectCtx(input));
      let parser = match.p;
      if (parser !== undefined) {
        if (match.a !== undefined) {
          return invalidOperation(input, "The S.transform doesn't allow parser and asyncParser at the same time. Remove parser in favor of asyncParser");
        } else {
          return embedTransformation(input, parser, false);
        }
      }
      let asyncParser = match.a;
      if (asyncParser !== undefined) {
        return embedTransformation(input, asyncParser, true);
      } else if (match.s !== undefined) {
        return invalidOperation(input, "The S.transform parser is missing");
      } else {
        return input;
      }
    };
    let to = base(unknownTag, false);
    mut.to = (to.decoder = noopDecoder, to.serializer = (input, param) => {
      let match = transformer(effectCtx(input));
      let serializer = match.s;
      if (serializer !== undefined) {
        return embedTransformation(input, serializer, false);
      } else if (match.a !== undefined || match.p !== undefined) {
        return invalidOperation(input, "The S.transform serializer is missing");
      } else {
        return input;
      }
    }, to);
    ((delete mut.isAsync));
  });
}

let nullAsUnit = base(nullTag, false);

nullAsUnit.const = null;

nullAsUnit.to = unit;

nullAsUnit.decoder = literalDecoder;

function neverBuilder(input, param) {
  input.c = input.c + embedInvalidInput(input, undefined) + ";";
  input.k = true;
  return input;
}

let never = base(neverTag, true);

never.decoder = neverBuilder;

let nestedLoc = "BS_PRIVATE_NESTED_SOME_NONE";

function factory(item) {
  let mut = base(objectTag, false);
  mut.properties = immutableEmpty;
  mut.additionalItems = item;
  mut.decoder = objectDecoder;
  return mut;
}

let metadataId = "m:Array.refinements";

function refinements(schema) {
  let m = schema[metadataId];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function isPriority(tagFlag, byKey) {
  if (tagFlag & 8320 && objectTag in byKey) {
    return true;
  } else if (tagFlag & 2048) {
    return numberTag in byKey;
  } else {
    return false;
  }
}

function isWiderUnionSchema(schemaAnyOf, inputAnyOf) {
  return inputAnyOf.every((inputSchema, idx) => {
    let schema = schemaAnyOf[idx];
    if (schema !== undefined && !(flags[inputSchema.type] & 9152) && inputSchema.type === schema.type && inputSchema.const === schema.const) {
      return inputSchema.to === undefined;
    } else {
      return false;
    }
  });
}

function unionDecoder(input, selfSchema) {
  let schemas = selfSchema.anyOf;
  let initialInputTagFlag = flags[input.s.type];
  let match = selfSchema.parser;
  let toPerCase;
  if (match !== undefined) {
    toPerCase = undefined;
  } else {
    let to = selfSchema.to;
    toPerCase = to !== undefined ? to : undefined;
  }
  if (initialInputTagFlag & 256 && isWiderUnionSchema(schemas, input.s.anyOf) && toPerCase === undefined) {
    return input;
  }
  if (input.s.encoder === undefined && initialInputTagFlag & 768) {
    input.s = unknown;
  }
  let initialInline = input.i;
  let fail = caught => embed(input, function () {
    let args = arguments;
    let errorDetails = makeInvalidInputDetails(selfSchema, unknown, input.path, args[0], true, args.length > 1 ? Array.from(args).slice(1) : undefined);
    throw new SuryError(errorDetails);
  }) + "(" + input.v() + caught + ")";
  let output = refine(input, undefined, undefined, undefined);
  let getArrItemsCode = (arr, isDeopt) => {
    let typeValidationInput = arr[0];
    let typeValidationOutput = arr[1];
    let itemStart = "";
    let itemEnd = "";
    let itemNextElse = false;
    let itemNoop = {
      contents: ""
    };
    let caught = "";
    let byDiscriminant = {};
    let itemIdx = 2;
    let lastIdx = arr.length - 1 | 0;
    while (itemIdx <= lastIdx) {
      let input = scope(typeValidationOutput);
      input.u = true;
      input.t = typeValidationOutput.t;
      input.e = arr[itemIdx];
      let isLast = itemIdx === lastIdx;
      let isFirst = itemIdx === 2;
      let withExhaustiveCheck = !(isFirst && isLast);
      let itemCode = "";
      let itemCond = "";
      try {
        let itemOutput = parse$1(input, undefined);
        let current = itemOutput;
        while (current !== undefined) {
          let val = current;
          current = val.prev;
          let currentCode = "";
          let validation = val.validation;
          if (validation !== undefined) {
            if (val.t === true ? val.prev.t !== true && val.cp === "" : true) {
              let input$1 = current;
              let inputVar = input$1.v();
              let condCode = validation(inputVar, false);
              itemCond = itemCond ? condCode + "&&" + itemCond : condCode;
            } else if (val.e.noValidation !== true) {
              let input$2 = current;
              let inputVar$1 = input$2.v();
              let validationCode = validation(inputVar$1, true);
              currentCode = "if(" + validationCode + "){" + embedInvalidInput(val, val.e) + "}";
            }
            
          }
          if (val.l !== "") {
            currentCode = currentCode + ("let " + val.l + ";");
          }
          ((delete val.a));
          currentCode = val.cp + currentCode + val.c;
          itemCode = currentCode + itemCode;
        };
        if (itemOutput.t) {
          output.t = true;
          if (itemOutput.f & 1) {
            output.f = output.f | 1;
          }
          itemCode = itemCode + (typeValidationInput.v() + "=" + itemOutput.i);
        }
        
      } catch (exn) {
        let errorVar = embed(input, getOrRethrow(exn));
        if (isLast) {
          withExhaustiveCheck = false;
        }
        let tmp;
        if (isLast && !isDeopt) {
          withExhaustiveCheck = false;
          tmp = fail("," + errorVar);
        } else {
          tmp = "throw " + errorVar;
        }
        itemCode = tmp;
      }
      let itemCond$1 = itemCond;
      let itemCode$1 = itemCode;
      if (itemCond$1) {
        if (itemCode$1) {
          let match = byDiscriminant[itemCond$1];
          if (match !== undefined) {
            if (typeof match === "string") {
              byDiscriminant[itemCond$1] = [
                match,
                itemCode$1
              ];
            } else {
              match.push(itemCode$1);
            }
          } else {
            byDiscriminant[itemCond$1] = itemCode$1;
          }
        } else {
          itemNoop.contents = itemNoop.contents ? itemNoop.contents + "||" + itemCond$1 : itemCond$1;
        }
      }
      if (!itemCond$1 || isLast) {
        let accedDiscriminants = Object.keys(byDiscriminant);
        for (let idx = 0, idx_finish = accedDiscriminants.length; idx < idx_finish; ++idx) {
          let discrim = accedDiscriminants[idx];
          let if_ = itemNextElse ? "else if" : "if";
          itemStart = itemStart + if_ + ("(" + discrim + "){");
          let code = byDiscriminant[discrim];
          if (typeof code === "string") {
            itemStart = itemStart + code + "}";
          } else {
            let caught$1 = "";
            for (let idx$1 = 0, idx_finish$1 = code.length; idx$1 < idx_finish$1; ++idx$1) {
              let code$1 = code[idx$1];
              let errorVar$1 = "e" + idx$1;
              itemStart = itemStart + ("try{" + code$1 + "}catch(" + errorVar$1 + "){");
              caught$1 = caught$1 + "," + errorVar$1;
            }
            itemStart = itemStart + fail(caught$1) + "}".repeat(code.length) + "}";
          }
          itemNextElse = true;
        }
        byDiscriminant = {};
      }
      if (!itemCond$1) {
        if (itemCode$1) {
          if (itemNoop.contents) {
            let if_$1 = itemNextElse ? "else if" : "if";
            itemStart = itemStart + if_$1 + ("(!(" + itemNoop.contents + ")){");
            itemEnd = "}" + itemEnd;
            itemNoop.contents = "";
            itemNextElse = false;
          }
          if (isLast && (isDeopt || !withExhaustiveCheck || isFirst)) {
            itemStart = itemStart + ((
              itemNextElse ? "else{" : ""
            ) + itemCode$1);
            itemEnd = (
              itemNextElse ? "}" : ""
            ) + itemEnd;
          } else {
            let errorVar$2 = "e" + (itemIdx - 2 | 0);
            itemStart = itemStart + ((
              itemNextElse ? "else{" : ""
            ) + "try{" + itemCode$1 + "}catch(" + errorVar$2 + "){");
            itemEnd = (
              itemNextElse ? "}" : ""
            ) + "}" + itemEnd;
            caught = caught + "," + errorVar$2;
            itemNextElse = false;
          }
        } else {
          itemNoop.contents = "";
          itemIdx = lastIdx;
          withExhaustiveCheck = false;
        }
      }
      if (isLast) {
        if (itemNoop.contents) {
          if (itemStart) {
            let if_$2 = itemNextElse ? "else if" : "if";
            itemStart = itemStart + if_$2 + ("(!(" + itemNoop.contents + ")){" + fail(caught) + "}");
          } else {
            typeValidationOutput.validation = appendValidation(typeValidationOutput.validation, (param, negative) => (
              negative ? "!" : ""
            ) + "(" + itemNoop.contents + ")");
          }
        } else if (withExhaustiveCheck) {
          let errorCode = fail(caught);
          itemStart = itemStart + (
            itemNextElse ? "else{" + errorCode + "}" : errorCode
          );
        }
        
      }
      itemIdx = itemIdx + 1;
    };
    return itemStart + itemEnd;
  };
  let start = "";
  let end = "";
  let caught = "";
  let exit = false;
  let lastIdx = schemas.length - 1 | 0;
  let byKey = {};
  let keys = [];
  let updatedSchemas = [];
  for (let idx = 0; idx <= lastIdx; ++idx) {
    let schema = toPerCase !== undefined ? updateOutput(schemas[idx], mut => {
        mut.to = toPerCase;
      }) : schemas[idx];
    updatedSchemas.push(schema);
    let tag = schema.type;
    let tagFlag = flags[tag];
    let key = tagFlag & 8192 ? schema.class.name : tag;
    if (!(tagFlag & 16 && "fromDefault" in selfSchema)) {
      let initialArr = byKey[key];
      if (initialArr !== undefined) {
        if (tagFlag & 64 && nestedLoc in schema.properties) {
          initialArr.splice(initialArr.length - 1 | 0, 0, schema);
        } else if (!(tagFlag & 2096)) {
          initialArr.push(schema);
        }
        
      } else {
        let typeValidationInput = scope(input);
        typeValidationInput.e = tagFlag & 32 ? nullLiteral : (
            tagFlag & 16 ? unit : (
                tagFlag & 64 ? factory(unknown) : (
                    tagFlag & 128 ? array(unknown) : (
                        tagFlag & 8192 ? instance(schema.class) : (
                            tagFlag & 2048 ? nan : (
                                tagFlag & 2 ? string : (
                                    tagFlag & 4 ? float : (
                                        tagFlag & 8 ? bool : (
                                            tagFlag & 1024 ? bigint : (
                                                tagFlag & 32768 ? symbol : unknown
                                              )
                                          )
                                      )
                                  )
                              )
                          )
                      )
                  )
              )
          );
        let typeValidationOutput;
        try {
          typeValidationOutput = parse$1(typeValidationInput, true);
        } catch (exn) {
          typeValidationInput.validation = undefined;
          typeValidationOutput = typeValidationInput;
        }
        if (isPriority(tagFlag, byKey)) {
          keys.unshift(key);
        } else {
          keys.push(key);
        }
        byKey[key] = [
          typeValidationInput,
          typeValidationOutput,
          schema
        ];
        let shouldDeopt = true;
        let valRef = typeValidationOutput;
        while (valRef !== undefined && shouldDeopt) {
          let v = valRef;
          valRef = v.prev;
          shouldDeopt = !(v.validation !== undefined && (
            v.t === true ? v.prev.t !== true && v.cp === "" : true
          ));
        };
        if (shouldDeopt) {
          for (let keyIdx = 0, keyIdx_finish = keys.length; keyIdx < keyIdx_finish; ++keyIdx) {
            let key$1 = keys[keyIdx];
            if (!exit) {
              let arr = byKey[key$1];
              let typeValidationOutput$1 = arr[1];
              let itemsCode = getArrItemsCode(arr, true);
              let blockCode = merge(typeValidationOutput$1) + itemsCode;
              if (blockCode) {
                let errorVar = "e" + (idx + keyIdx | 0);
                start = start + ("try{" + blockCode + "}catch(" + errorVar + "){");
                end = "}" + end;
                caught = caught + "," + errorVar;
              } else {
                exit = true;
              }
            }
            
          }
          byKey = {};
          keys = [];
        }
        
      }
    }
    
  }
  let byKey$1 = byKey;
  let keys$1 = keys;
  if (!exit) {
    let nextElse = false;
    let noop = "";
    for (let idx$1 = 0, idx_finish = keys$1.length; idx$1 < idx_finish; ++idx$1) {
      let arr$1 = byKey$1[keys$1[idx$1]];
      let typeValidationOutput$2 = arr$1[1];
      let firstSchema = arr$1[2];
      let itemsCode$1 = getArrItemsCode(arr$1, false);
      let blockCode$1 = "";
      let blockCond = "";
      let current = typeValidationOutput$2;
      while (current !== undefined) {
        let val = current;
        current = val.prev;
        let currentCode = "";
        let validation = val.validation;
        if (validation !== undefined) {
          if (val.t === true ? val.prev.t !== true && val.cp === "" : true) {
            let input$1 = current;
            let inputVar = input$1.v();
            let condCode = validation(inputVar, false);
            blockCond = blockCond ? condCode + "&&" + blockCond : condCode;
          } else if (val.e.noValidation !== true) {
            let input$2 = current;
            let inputVar$1 = input$2.v();
            let validationCode = validation(inputVar$1, true);
            currentCode = "if(" + validationCode + "){" + embedInvalidInput(val, val.e) + "}";
          }
          
        }
        if (val.l !== "") {
          currentCode = currentCode + ("let " + val.l + ";");
        }
        ((delete val.a));
        currentCode = val.cp + currentCode + val.c;
        blockCode$1 = currentCode + blockCode$1;
      };
      let blockCode$2 = blockCode$1 + itemsCode$1;
      let blockCond$1 = blockCond;
      if (blockCode$2 || isPriority(flags[firstSchema.type], byKey$1)) {
        let if_ = nextElse ? "else if" : "if";
        start = start + if_ + ("(" + blockCond$1 + "){" + blockCode$2 + "}");
        nextElse = true;
      } else {
        noop = noop ? noop + "||" + blockCond$1 : blockCond$1;
      }
    }
    let errorCode = fail(caught);
    let tmp;
    if (noop) {
      let if_$1 = nextElse ? "else if" : "if";
      tmp = if_$1 + ("(!(" + noop + ")){" + errorCode + "}");
    } else {
      tmp = nextElse ? "else{" + errorCode + "}" : errorCode;
    }
    start = start + tmp;
  }
  output.c = output.c + start + end;
  if (input.i !== output.i) {
    output.i = input.i;
  }
  let o = output.f & 1 ? (output.i = "Promise.resolve(" + output.i + ")", output) : (
      output.v === _var && input.c === "" && output.c === "" && (output.l === output.i + "=" + initialInline || initialInline === "i") ? (input.l = "", input.a = initialAllocate, input.v = _notVar, input.i = initialInline, input) : output
    );
  o.s = toPerCase !== undefined ? (o.k = true, getOutputSchema(toPerCase)) : selfSchema;
  return o;
}

function factory$1(schemas) {
  let len = schemas.length;
  if (len === 1) {
    return schemas[0];
  }
  if (len !== 0) {
    let has = {};
    let anyOf = new Set();
    for (let idx = 0, idx_finish = schemas.length; idx < idx_finish; ++idx) {
      let schema = schemas[idx];
      if (schema.type === unionTag && schema.to === undefined) {
        schema.anyOf.forEach(item => {
          anyOf.add(item);
        });
        Object.assign(has, schema.has);
      } else {
        anyOf.add(schema);
        setHas(has, schema.type);
      }
    }
    let mut = base(unionTag, false);
    mut.anyOf = Array.from(anyOf);
    mut.decoder = unionDecoder;
    mut.has = has;
    return mut;
  }
  throw new Error("[Sury] S.union requires at least one item");
}

function nestedNone() {
  let itemSchema = parse(0);
  let properties = {};
  properties[nestedLoc] = itemSchema;
  return {
    type: objectTag,
    serializer: (input, selfSchema) => nextConst(input, selfSchema.to, undefined),
    decoder: objectDecoder,
    additionalItems: "strip",
    properties: properties
  };
}

function parser(input, selfSchema) {
  return next(input, "{" + nestedLoc + ":" + getOutputSchema(selfSchema).properties[nestedLoc].const + "}", selfSchema.to, undefined);
}

function nestedOption(item) {
  return updateOutput(item, mut => {
    mut.to = nestedNone();
    mut.parser = parser;
  });
}

function factory$2(item, unitOpt) {
  let unit$1 = unitOpt !== undefined ? unitOpt : unit;
  let match = getOutputSchema(item);
  let match$1 = match.type;
  switch (match$1) {
    case "undefined" :
      return factory$1([
        unit$1,
        nestedOption(item)
      ]);
    case "union" :
      let has = match.has;
      let anyOf = match.anyOf;
      return updateOutput(item, mut => {
        let mutHas = copy(has);
        let newAnyOf = [];
        for (let idx = 0, idx_finish = anyOf.length; idx < idx_finish; ++idx) {
          let schema = anyOf[idx];
          let match = getOutputSchema(schema);
          let match$1 = match.type;
          let tmp;
          if (match$1 === "undefined") {
            mutHas[unit$1.type] = true;
            newAnyOf.push(unit$1);
            tmp = nestedOption(schema);
          } else {
            let properties = match.properties;
            if (properties !== undefined) {
              let nestedSchema = properties[nestedLoc];
              tmp = nestedSchema !== undefined ? updateOutput(schema, mut => {
                  let properties = {};
                  let newrecord = {...nestedSchema};
                  newrecord.const = nestedSchema.const + 1;
                  properties[nestedLoc] = newrecord;
                  mut.properties = properties;
                }) : schema;
            } else {
              tmp = schema;
            }
          }
          newAnyOf.push(tmp);
        }
        if (newAnyOf.length === anyOf.length) {
          mutHas[unit$1.type] = true;
          newAnyOf.push(unit$1);
        }
        mut.anyOf = newAnyOf;
        mut.has = mutHas;
      });
    default:
      return factory$1([
        item,
        unit$1
      ]);
  }
}

function getWithDefault(schema, $$default) {
  return updateOutput(schema, mut => {
    let anyOf = mut.anyOf;
    if (anyOf !== undefined) {
      let item;
      let itemOutputSchema;
      for (let idx = 0, idx_finish = anyOf.length; idx < idx_finish; ++idx) {
        let schema = anyOf[idx];
        let outputSchema = getOutputSchema(schema);
        let match = outputSchema.type;
        if (match !== "undefined") {
          let match$1 = item;
          if (match$1 !== undefined) {
            let message = "Can't set default for " + toExpression(mut);
            throw new Error("[Sury] " + message);
          }
          item = schema;
          itemOutputSchema = outputSchema;
        }
        
      }
      let s = item;
      let item$1;
      if (s !== undefined) {
        item$1 = s;
      } else {
        let message$1 = "Can't set default for " + toExpression(mut);
        throw new Error("[Sury] " + message$1);
      }
      mut.parser = (input, selfSchema) => {
        let operation = input => {
          let inputVar = input.v();
          let tmp;
          tmp = $$default.TAG === "Value" ? inlineConst(input, parse($$default._0)) : embed(input, $$default._0) + "()";
          return next(input, inputVar + "===void 0?" + tmp + ":" + inputVar, selfSchema.to, selfSchema.to);
        };
        if (!(input.f & 1)) {
          return operation(input);
        }
        let operationInputVar = varWithoutAllocation(input.g);
        let operationInput = next(input, operationInputVar, input.s, input.e);
        operationInput.v = _var;
        operationInput.prev = undefined;
        let operationOutputVal = operation(operationInput);
        let output = parse$1(operationOutputVal, undefined);
        let operationCode = merge(output);
        input.i = input.i + ".then(" + operationInputVar + "=>{" + operationCode + "return " + output.i + "})";
        input.s = output.s;
        input.e = output.e;
        return input;
      };
      let to = copySchema(itemOutputSchema);
      to.serializer = to.decoder;
      to.decoder = (input, param) => input;
      mut.to = to;
      if ($$default.TAG !== "Value") {
        return;
      }
      try {
        mut.default = getDecoder(reverse(item$1), undefined)($$default._0);
        return;
      } catch (exn) {
        return;
      }
    } else {
      let message$2 = "Can't set default for " + toExpression(mut);
      throw new Error("[Sury] " + message$2);
    }
  });
}

function getOr(schema, defalutValue) {
  return getWithDefault(schema, {
    TAG: "Value",
    _0: defalutValue
  });
}

function getOrWith(schema, defalutCb) {
  return getWithDefault(schema, {
    TAG: "Callback",
    _0: defalutCb
  });
}

function setAdditionalItems(schema, additionalItems, deep) {
  let currentAdditionalItems = schema.additionalItems;
  if (currentAdditionalItems === undefined) {
    return schema;
  }
  if (currentAdditionalItems === additionalItems || typeof currentAdditionalItems === objectTag) {
    return schema;
  }
  let mut = copySchema(schema);
  mut.additionalItems = additionalItems;
  if (deep) {
    let items = schema.items;
    if (items !== undefined) {
      let newItems = [];
      for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
        let s = items[idx];
        newItems.push(setAdditionalItems(s, additionalItems, deep));
      }
      mut.items = newItems;
    }
    let properties = schema.properties;
    if (properties !== undefined) {
      let newProperties = {};
      let keys = Object.keys(properties);
      for (let idx$1 = 0, idx_finish$1 = keys.length; idx$1 < idx_finish$1; ++idx$1) {
        let key = keys[idx$1];
        newProperties[key] = setAdditionalItems(properties[key], additionalItems, deep);
      }
      mut.properties = newProperties;
    }
    
  }
  return mut;
}

function strip(schema) {
  return setAdditionalItems(schema, "strip", false);
}

function deepStrip(schema) {
  return setAdditionalItems(schema, "strip", true);
}

function strict(schema) {
  return setAdditionalItems(schema, "strict", false);
}

function deepStrict(schema) {
  return setAdditionalItems(schema, "strict", true);
}

let Tuple = {};

let metadataId$1 = "m:String.refinements";

function refinements$1(schema) {
  let m = schema[metadataId$1];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

let cuidRegex = /^c[^\s-]{8,}$/i;

let uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;

let emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;

let datetimeRe = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/;

function jsonEncoder(input, to) {
  let toTagFlag = flags[to.type];
  if (toTagFlag & 46) {
    let output = parse$1(refine(input, unknown, undefined, to), undefined);
    output.k = true;
    return output;
  }
  if (toTagFlag & 1024) {
    let jsonExpected = copySchema(string);
    jsonExpected.to = to;
    let output$1 = parse$1(refine(input, unknown, undefined, jsonExpected), undefined);
    output$1.k = true;
    return output$1;
  }
  if (toTagFlag & 2064) {
    let jsonExpected$1 = copySchema(nullLiteral);
    jsonExpected$1.to = to;
    let output$2 = parse$1(refine(input, unknown, undefined, jsonExpected$1), undefined);
    output$2.k = true;
    return output$2;
  }
  if (toTagFlag & 128) {
    let jsonExpected$2 = array(unknown);
    let output$3 = parse$1(refine(input, unknown, undefined, jsonExpected$2), undefined);
    output$3.s.additionalItems = json;
    output$3.e = to;
    return output$3;
  }
  if (!(toTagFlag & 64)) {
    return input;
  }
  let jsonExpected$3 = factory(unknown);
  let output$4 = parse$1(refine(input, unknown, undefined, jsonExpected$3), undefined);
  output$4.s.additionalItems = json;
  output$4.e = to;
  return output$4;
}

function jsonDecoder(input, param) {
  let inputTagFlag = flags[input.s.type];
  if (inputTagFlag & 46 || input.s.$ref === json.$ref) {
    return input;
  }
  if (inputTagFlag & 2064) {
    return nextConst(input, nullLiteral, undefined);
  }
  if (inputTagFlag & 1024) {
    return inputToString(input);
  }
  if (inputTagFlag & 128) {
    let expected = base(arrayTag, false);
    expected.items = input.s.items.map(param => json);
    expected.decoder = arrayDecoder;
    let v = input.s.additionalItems;
    let tmp;
    tmp = v === "strip" || v === "strict" ? v : json;
    expected.additionalItems = tmp;
    expected.to = input.e.to;
    let output = parse$1(refine(input, undefined, undefined, expected), undefined);
    output.k = true;
    return output;
  }
  if (inputTagFlag & 64) {
    let expected$1 = base(objectTag, false);
    let properties = {};
    Object.keys(input.s.properties).forEach(key => {
      properties[key] = json;
    });
    expected$1.properties = properties;
    let v$1 = input.s.additionalItems;
    let tmp$1;
    tmp$1 = v$1 === "strip" || v$1 === "strict" ? v$1 : json;
    expected$1.additionalItems = tmp$1;
    expected$1.decoder = objectDecoder;
    expected$1.to = input.e.to;
    let output$1 = parse$1(refine(input, undefined, undefined, expected$1), undefined);
    output$1.k = true;
    return output$1;
  }
  if (inputTagFlag & 512) {
    return recursiveDecoder(input, input.e);
  }
  if (!(inputTagFlag & 1)) {
    return unsupportedConversion(input, input.s, input.e);
  }
  let to = input.e.to;
  let preEncode = to && !input.e.parser;
  if (preEncode) {
    input.s = json;
    return jsonEncoder(input, input.e);
  } else if (input.e.noValidation) {
    input.s = json;
    return input;
  } else {
    return recursiveDecoder(input, input.e);
  }
}

function enableJson() {
  if (!json[shakenRef]) {
    return;
  }
  ((delete json.as));
  let jsonRef = base(refTag, true);
  jsonRef.$ref = defsPath + jsonName;
  jsonRef.name = jsonName;
  jsonRef.decoder = jsonDecoder;
  jsonRef.encoder = jsonEncoder;
  json.type = jsonRef.type;
  json.$ref = jsonRef.$ref;
  json.name = jsonName;
  json.decoder = jsonDecoder;
  json.encoder = jsonEncoder;
  let anyOf = [
    string,
    bool,
    float,
    nullLiteral,
    factory(jsonRef),
    array(jsonRef)
  ];
  let has = {};
  anyOf.forEach(schema => {
    has[schema.type] = true;
  });
  let jsonDef = base(unionTag, true);
  jsonDef.anyOf = anyOf;
  jsonDef.has = has;
  jsonDef.decoder = unionDecoder;
  jsonDef.name = jsonName;
  jsonDef.type = unionTag;
  let defs = {};
  defs[jsonName] = jsonDef;
  json.$defs = defs;
}

function inlineJsonString(input, schema) {
  let tagFlag = flags[schema.type];
  let $$const = schema.const;
  if (tagFlag & 48) {
    return "\"null\"";
  } else if (tagFlag & 2) {
    return JSON.stringify(fromString($$const));
  } else if (tagFlag & 1024) {
    return "\"\\\"" + $$const + "\\\"\"";
  } else if (tagFlag & 12) {
    return "\"" + $$const + "\"";
  } else {
    return unsupportedConversion(input, schema, input.e);
  }
}

function constSchemaToJsonStringConst(input, schema) {
  let tagFlag = flags[schema.type];
  let $$const = schema.const;
  if (tagFlag & 48) {
    return "null";
  } else if (tagFlag & 2) {
    return fromString($$const);
  } else if (tagFlag & 1024) {
    return "\"" + $$const + "\"";
  } else if (tagFlag & 12) {
    return (""+$$const);
  } else {
    return unsupportedConversion(input, schema, input.e);
  }
}

function jsonStringEncoder(input, to) {
  if (to.format === "json") {
    return input;
  }
  if (constField in to) {
    let jsonStringConstSchema = base(stringTag, true);
    jsonStringConstSchema.const = constSchemaToJsonStringConst(input, to);
    jsonStringConstSchema.to = to;
    jsonStringConstSchema.decoder = literalDecoder;
    let output = parse$1(refine(input, undefined, undefined, jsonStringConstSchema), undefined);
    output.k = true;
    return output;
  }
  let outputVar = varWithoutAllocation(input.g);
  input.a(outputVar);
  let nextSchema = copySchema(json);
  nextSchema.to = to;
  let output$1 = next(input, outputVar, nextSchema, nextSchema);
  output$1.v = _var;
  let inputVar = input.v();
  output$1.cp = "try{" + outputVar + "=JSON.parse(" + inputVar + ")}catch(t){" + embedInvalidInput(input, undefined) + "}";
  let v = parse$1(output$1, undefined);
  v.k = true;
  return v;
}

function jsonStringDecoder(input, param) {
  let inputTagFlag = flags[input.s.type];
  let expectedSchema = input.e;
  if (inputTagFlag & 1) {
    let to = expectedSchema.to;
    let preEncode = to && to.type !== unknownTag && !expectedSchema.parser;
    let stringVal = stringDecoder(input, null);
    stringVal.s = string;
    stringVal.e = expectedSchema;
    if (preEncode) {
      return jsonStringEncoder(stringVal, to);
    }
    let stringVar = stringVal.v();
    let output = refine(stringVal, expectedSchema, undefined, undefined);
    output.cp = "try{JSON.parse(" + stringVar + ")}catch(t){" + embedInvalidInput(stringVal, undefined) + "}";
    return output;
  }
  if (input.s.format === "json") {
    return input;
  }
  if (constField in input.s) {
    return next(input, inlineJsonString(input, input.s), expectedSchema, undefined);
  }
  if (inputTagFlag & 2) {
    return next(input, "JSON.stringify(" + input.i + ")", expectedSchema, undefined);
  }
  if (inputTagFlag & 12) {
    let output$1 = inputToString(input);
    output$1.s = expectedSchema;
    return output$1;
  }
  if (inputTagFlag & 1024) {
    return next(input, "\"\\\"\"+" + input.i + "+\"\\\"\"", expectedSchema, undefined);
  }
  if (!(inputTagFlag & 192)) {
    return unsupportedConversion(input, input.s, expectedSchema);
  }
  let jsonVal = parse$1(refine(input, undefined, undefined, json), undefined);
  let v = expectedSchema.space;
  return next(jsonVal, "JSON.stringify(" + jsonVal.i + (
    v !== undefined && v !== 0 ? ",null," + v : ""
  ) + ")", expectedSchema, expectedSchema);
}

function enableJsonString() {
  if (jsonString[shakenRef]) {
    ((delete jsonString.as));
    enableJson();
    jsonString.type = stringTag;
    jsonString.format = "json";
    jsonString.name = jsonName + " string";
    jsonString.encoder = jsonStringEncoder;
    jsonString.decoder = jsonStringDecoder;
    return;
  }
  
}

let uint8Array = shaken("uint8Array");

function enableUint8Array() {
  if (uint8Array[shakenRef]) {
    ((delete uint8Array.as));
    uint8Array.type = instanceTag;
    uint8Array.class = (Uint8Array);
    uint8Array.decoder = (inputArg, param) => {
      let inputTagFlag = flags[inputArg.s.type];
      let input = inputArg;
      if (inputTagFlag & 2) {
        input = next(input, embed(input, (new TextEncoder())) + ".encode(" + input.i + ")", uint8Array, undefined);
      } else if (inputTagFlag & 8193) {
        input = instanceDecoder(input, null);
      }
      let match = inputArg.e;
      let match$1 = match.parser;
      if (match$1 !== undefined) {
        return input;
      }
      let to = match.to;
      if (to === undefined) {
        return input;
      }
      let toTagFlag = flags[to.type];
      if (toTagFlag & 2) {
        input = next(input, embed(input, (new TextDecoder())) + ".decode(" + input.i + ")", string, undefined);
      }
      return input;
    };
    return;
  }
  
}

let metadataId$2 = "m:Int.refinements";

function refinements$2(schema) {
  let m = schema[metadataId$2];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

let metadataId$3 = "m:Float.refinements";

function refinements$3(schema) {
  let m = schema[metadataId$3];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function to(from, target) {
  if (from === target) {
    return from;
  } else {
    return updateOutput(from, mut => {
      mut.to = target;
    });
  }
}

function list(schema) {
  return transform(array(schema), param => ({
    p: Belt_List.fromArray,
    s: Belt_List.toArray
  }));
}

function meta(schema, data) {
  let mut = copySchema(schema);
  let name = data.name;
  if (name !== undefined) {
    if (name === "") {
      mut.name = undefined;
    } else {
      mut.name = name;
    }
  }
  let title = data.title;
  if (title !== undefined) {
    if (title === "") {
      mut.title = undefined;
    } else {
      mut.title = title;
    }
  }
  let description = data.description;
  if (description !== undefined) {
    if (description === "") {
      mut.description = undefined;
    } else {
      mut.description = description;
    }
  }
  let deprecated = data.deprecated;
  if (deprecated !== undefined) {
    mut.deprecated = deprecated;
  }
  let examples = data.examples;
  if (examples !== undefined) {
    if (examples.length !== 0) {
      mut.examples = examples.map(getDecoder(reverse(schema), undefined));
    } else {
      mut.examples = undefined;
    }
  }
  return mut;
}

function brand(schema, id) {
  let mut = copySchema(schema);
  mut.name = id;
  return mut;
}

function toEmbededItem(definition) {
  return definition[itemSymbol];
}

function proxifyShapedSchema(schema, from, fromFlattened) {
  let mut = copySchema(getOutputSchema(schema));
  mut.from = from;
  if (fromFlattened !== undefined) {
    mut.fromFlattened = fromFlattened;
  }
  return new Proxy(mut, {
    get: (target, prop) => {
      if (prop === itemSymbol) {
        return target;
      }
      let items = target.items;
      let properties = target.properties;
      let maybeField = properties !== undefined ? properties[prop] : (
          items !== undefined ? items[prop] : undefined
        );
      if (maybeField === undefined) {
        let message = "Cannot read property \"" + prop + "\" of " + toExpression(target);
        throw new Error("[Sury] " + message);
      }
      return proxifyShapedSchema(maybeField, target.from.concat(prop), target.fromFlattened);
    }
  });
}

function getShapedSerializerOutput(input, acc, targetSchema, path) {
  if (acc !== undefined) {
    let val = acc.val;
    if (val !== undefined) {
      let v = scope(val);
      v.t = true;
      return v;
    }
    
  }
  if (constField in targetSchema) {
    let v$1 = nextConst(input, targetSchema, targetSchema);
    v$1.prev = undefined;
    v$1.p = input;
    v$1.v = _notVarAtParent;
    return v$1;
  }
  let v$2 = makeObjectVal(input, targetSchema);
  v$2.e = targetSchema;
  v$2.prev = undefined;
  v$2.p = input;
  v$2.v = _notVarAtParent;
  let flattened = targetSchema.flattened;
  let items = targetSchema.items;
  if (items !== undefined) {
    for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
      let location = idx.toString();
      let tmp;
      if (acc !== undefined) {
        let properties = acc.properties;
        tmp = properties !== undefined ? properties[location] : undefined;
      } else {
        tmp = undefined;
      }
      let inlinedLocation = inlineLocation(input.g, location);
      add(v$2, location, getShapedSerializerOutput(input, tmp, items[idx], path + ("[" + inlinedLocation + "]")));
    }
  } else {
    let properties$1 = targetSchema.properties;
    if (properties$1 !== undefined) {
      if (flattened !== undefined && acc !== undefined) {
        let flattenedAcc = acc.flattened;
        if (flattenedAcc !== undefined) {
          flattenedAcc.forEach((acc, idx) => {
            let flattenedOutput = getShapedSerializerOutput(input, acc, reverse(flattened[idx]), path);
            let vals = flattenedOutput.d;
            let locations = Object.keys(vals);
            for (let idx$1 = 0, idx_finish = locations.length; idx$1 < idx_finish; ++idx$1) {
              let location = locations[idx$1];
              add(v$2, location, vals[location]);
            }
          });
        }
        
      }
      let keys = Object.keys(properties$1);
      for (let idx$1 = 0, idx_finish$1 = keys.length; idx$1 < idx_finish$1; ++idx$1) {
        let location$1 = keys[idx$1];
        if (!(location$1 in v$2.d)) {
          let tmp$1;
          if (acc !== undefined) {
            let properties$2 = acc.properties;
            tmp$1 = properties$2 !== undefined ? properties$2[location$1] : undefined;
          } else {
            tmp$1 = undefined;
          }
          let inlinedLocation$1 = inlineLocation(input.g, location$1);
          add(v$2, location$1, getShapedSerializerOutput(input, tmp$1, properties$1[location$1], path + ("[" + inlinedLocation$1 + "]")));
        }
        
      }
    } else {
      let from = targetSchema.from;
      let path$1 = from !== undefined ? path + from.map(item => "[\"" + item + "\"]").join("") : path;
      let tmp$2 = path$1 === "" ? "" : " at " + path$1;
      invalidOperation(input, "Missing input for " + toExpression(targetSchema) + tmp$2);
    }
  }
  return complete(v$2);
}

function traverseDefinition(definition, onNode) {
  if (typeof definition !== "object" || definition === null) {
    return parse(definition);
  }
  let s = onNode(definition);
  if (s !== undefined) {
    return s;
  }
  if (Array.isArray(definition)) {
    for (let idx = 0, idx_finish = definition.length; idx < idx_finish; ++idx) {
      let schema = traverseDefinition(definition[idx], onNode);
      definition[idx] = schema;
    }
    let mut = base(arrayTag, false);
    mut.items = definition;
    mut.additionalItems = "strict";
    mut.decoder = arrayDecoder;
    return mut;
  }
  let cnstr = definition.constructor;
  if (cnstr && cnstr !== Object) {
    let mut$1 = base(instanceTag, true);
    mut$1.class = cnstr;
    mut$1.const = definition;
    mut$1.decoder = literalDecoder;
    return mut$1;
  }
  let fieldNames = Object.keys(definition);
  let length = fieldNames.length;
  for (let idx$1 = 0; idx$1 < length; ++idx$1) {
    let location = fieldNames[idx$1];
    let schema$1 = traverseDefinition(definition[location], onNode);
    definition[location] = schema$1;
  }
  let mut$2 = base(objectTag, false);
  mut$2.properties = definition;
  mut$2.additionalItems = globalConfig.a;
  mut$2.decoder = objectDecoder;
  return mut$2;
}

function shapedSerializer(input, param) {
  let acc = {};
  prepareShapedSerializerAcc(acc, input);
  let targetSchema = input.e.to;
  let output = getShapedSerializerOutput(input, acc, targetSchema, "");
  output.prev = input;
  return output;
}

function getValByFrom(_input, from, _idx) {
  while (true) {
    let idx = _idx;
    let input = _input;
    let key = from[idx];
    if (key === undefined) {
      return input;
    }
    _idx = idx + 1 | 0;
    _input = input.d[key];
    continue;
  };
}

function prepareShapedSerializerAcc(acc, input) {
  let match = input.e;
  let from = match.from;
  if (from !== undefined) {
    let fromFlattened = match.fromFlattened;
    let accAtFrom;
    if (fromFlattened !== undefined) {
      if (acc.flattened === undefined) {
        acc.flattened = [];
      }
      let acc$1 = acc.flattened[fromFlattened];
      if (acc$1 !== undefined) {
        accAtFrom = acc$1;
      } else {
        let newAcc = {};
        acc.flattened[fromFlattened] = newAcc;
        accAtFrom = newAcc;
      }
    } else {
      accAtFrom = acc;
    }
    for (let idx = 0, idx_finish = from.length; idx < idx_finish; ++idx) {
      let key = from[idx];
      let p = accAtFrom.properties;
      let p$1;
      if (p !== undefined) {
        p$1 = p;
      } else {
        let p$2 = {};
        accAtFrom.properties = p$2;
        p$1 = p$2;
      }
      let acc$2 = p$1[key];
      let tmp;
      if (acc$2 !== undefined) {
        tmp = acc$2;
      } else {
        let newAcc$1 = {};
        p$1[key] = newAcc$1;
        tmp = newAcc$1;
      }
      accAtFrom = tmp;
    }
    accAtFrom.val = input;
    return;
  }
  let vals = input.d;
  if (vals === undefined) {
    return;
  }
  let keys = Object.keys(vals);
  for (let idx$1 = 0, idx_finish$1 = keys.length; idx$1 < idx_finish$1; ++idx$1) {
    prepareShapedSerializerAcc(acc, vals[keys[idx$1]]);
  }
}

function getShapedParserOutput(input, targetSchema) {
  let from = targetSchema.from;
  let fromFlattened = targetSchema.fromFlattened;
  let v;
  if (fromFlattened !== undefined) {
    v = scope(getValByFrom(input.fv[fromFlattened], targetSchema.from, 0));
  } else if (from !== undefined) {
    v = scope(getValByFrom(input, from, 0));
  } else if (constField in targetSchema) {
    v = nextConst(input, targetSchema, undefined);
  } else {
    let output = makeObjectVal(input, targetSchema);
    let items = targetSchema.items;
    if (items !== undefined) {
      for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
        let location = idx.toString();
        add(output, location, getShapedParserOutput(input, items[idx]));
      }
    } else {
      let properties = targetSchema.properties;
      if (properties !== undefined) {
        let keys = Object.keys(properties);
        for (let idx$1 = 0, idx_finish$1 = keys.length; idx$1 < idx_finish$1; ++idx$1) {
          let location$1 = keys[idx$1];
          add(output, location$1, getShapedParserOutput(input, properties[location$1]));
        }
      } else {
        let message = "Don't know where the value is coming from: " + toExpression(targetSchema);
        throw new Error("[Sury] " + message);
      }
    }
    v = complete(output);
  }
  v.prev = undefined;
  return v;
}

function nested(fieldName) {
  let parentCtx = this;
  let cacheId = "~" + fieldName;
  let ctx = parentCtx[cacheId];
  if (ctx !== undefined) {
    return Primitive_option.valFromOption(ctx);
  }
  let properties = {};
  let schema = base(objectTag, false);
  schema.properties = properties;
  schema.additionalItems = globalConfig.a;
  schema.decoder = objectDecoder;
  let parentSchema = parentCtx.f(fieldName, schema)[itemSymbol];
  let field = (fieldName, schema) => {
    let inlinedLocation = fromString(fieldName);
    if (fieldName in properties) {
      throw new Error("[Sury] " + ("The field " + inlinedLocation + " defined twice"));
    }
    properties[fieldName] = schema;
    return proxifyShapedSchema(schema, parentSchema.from.concat(fieldName), parentSchema.fromFlattened);
  };
  let tag = (tag$1, asValue) => {
    field(tag$1, definitionToSchema(asValue));
  };
  let fieldOr = (fieldName, schema, or) => {
    let schema$1 = factory$2(schema, undefined);
    return field(fieldName, getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    }));
  };
  let flatten = schema => {
    let match = schema.type;
    if (match === "object") {
      let to = schema.to;
      let flattenedProperties = schema.properties;
      if (to) {
        let message = "Unsupported nested flatten for transformed object schema " + toExpression(schema);
        throw new Error("[Sury] " + message);
      }
      let flattenedKeys = Object.keys(flattenedProperties);
      let result = {};
      for (let idx = 0, idx_finish = flattenedKeys.length; idx < idx_finish; ++idx) {
        let key = flattenedKeys[idx];
        result[key] = field(key, flattenedProperties[key]);
      }
      return result;
    }
    let message$1 = "Can't flatten " + toExpression(schema) + " schema";
    throw new Error("[Sury] " + message$1);
  };
  let ctx$1 = {
    field: field,
    f: field,
    fieldOr: fieldOr,
    tag: tag,
    nested: nested,
    flatten: flatten
  };
  parentCtx[cacheId] = ctx$1;
  return ctx$1;
}

function definitionToSchema(definition) {
  return traverseDefinition(definition, node => {
    if (node["~standard"]) {
      return node;
    }
    
  });
}

function shapedParser(input, selfSchema) {
  let flattened = selfSchema.flattened;
  if (flattened !== undefined) {
    let flattenedVals = [];
    for (let idx = 0, idx_finish = flattened.length; idx < idx_finish; ++idx) {
      let flattenedSchema = flattened[idx];
      let flattenedInput = scope(input);
      flattenedInput.e = flattenedSchema;
      flattenedVals.push(parse$1(flattenedInput, undefined));
    }
    input.fv = flattenedVals;
  }
  let targetSchema = selfSchema.to;
  let output = getShapedParserOutput(input, targetSchema);
  output.prev = input;
  output.k = targetSchema.to === undefined;
  return output;
}

function definitionToShapedSchema(definition) {
  let s = copySchema(traverseDefinition(definition, toEmbededItem));
  s.serializer = shapedSerializer;
  return s;
}

function shape(schema, definer) {
  return updateOutput(schema, mut => {
    let fromProxy = proxifyShapedSchema(mut, immutableEmpty$1, undefined);
    let definition = definer(fromProxy);
    if (definition === fromProxy) {
      return;
    } else {
      mut.parser = shapedParser;
      mut.to = definitionToShapedSchema(definition);
      return;
    }
  });
}

function object(definer) {
  let flattened = (void 0);
  let properties = {};
  let flatten = schema => {
    let match = schema.type;
    if (match === "object") {
      let flattenedProperties = schema.properties;
      let flattenedKeys = Object.keys(flattenedProperties);
      for (let idx = 0, idx_finish = flattenedKeys.length; idx < idx_finish; ++idx) {
        let key = flattenedKeys[idx];
        let flattenedSchema = flattenedProperties[key];
        let schema$1 = properties[key];
        if (schema$1 !== undefined) {
          if (schema$1 !== flattenedSchema) {
            throw new Error("[Sury] " + ("The field \"" + key + "\" defined twice with incompatible schemas"));
          }
          
        } else {
          properties[key] = flattenedSchema;
        }
      }
      let f = (flattened || (flattened = []));
      return proxifyShapedSchema(schema, immutableEmpty$1, f.push(schema) - 1 | 0);
    }
    let message = "The '" + toExpression(schema) + "' schema can't be flattened";
    throw new Error("[Sury] " + message);
  };
  let field = (fieldName, schema) => {
    if (fieldName in properties) {
      throw new Error("[Sury] " + ("The field \"" + fieldName + "\" defined twice with incompatible schemas"));
    }
    properties[fieldName] = schema;
    return proxifyShapedSchema(schema, [fieldName], undefined);
  };
  let tag = (tag$1, asValue) => {
    field(tag$1, definitionToSchema(asValue));
  };
  let fieldOr = (fieldName, schema, or) => {
    let schema$1 = factory$2(schema, undefined);
    return field(fieldName, getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    }));
  };
  let ctx = {
    field: field,
    f: field,
    fieldOr: fieldOr,
    tag: tag,
    nested: nested,
    flatten: flatten
  };
  let definition = definer(ctx);
  let mut = base(objectTag, false);
  mut.properties = properties;
  mut.additionalItems = globalConfig.a;
  mut.decoder = objectDecoder;
  mut.parser = shapedParser;
  mut.to = definitionToShapedSchema(definition);
  if (flattened !== undefined) {
    mut.flattened = flattened;
  }
  return mut;
}

function tuple(definer) {
  let items = [];
  let item = (idx, schema) => {
    let location = idx.toString();
    if (items[idx]) {
      throw new Error("[Sury] " + ("The item [" + location + "] is defined multiple times"));
    }
    items[idx] = schema;
    return proxifyShapedSchema(schema, [idx.toString()], undefined);
  };
  let tag = (idx, asValue) => {
    item(idx, definitionToSchema(asValue));
  };
  let ctx = {
    item: item,
    tag: tag
  };
  let definition = definer(ctx);
  for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
    if (!items[idx]) {
      items[idx] = unit;
    }
    
  }
  let mut = base(arrayTag, false);
  mut.items = items;
  mut.additionalItems = "strict";
  mut.decoder = arrayDecoder;
  mut.parser = shapedParser;
  mut.to = definitionToShapedSchema(definition);
  return mut;
}

function matches(schema) {
  return schema;
}

let ctx = {
  m: matches
};

function factory$3(definer) {
  return definitionToSchema(definer(ctx));
}

let js_schema = definitionToSchema;

function $$enum(values) {
  return factory$1(values.map(js_schema));
}

function unnestSerializer(input, selfSchema) {
  let schema = selfSchema.additionalItems;
  let items = schema.items;
  let inputVar = input.v();
  let iteratorVar = varWithoutAllocation(input.g);
  let outputVar = varWithoutAllocation(input.g);
  let newrecord = {...input};
  newrecord.f = 0;
  newrecord.s = unknown;
  newrecord.i = inputVar + "[" + iteratorVar + "]";
  newrecord.v = _var;
  let itemOutput = withPathPrepend(newrecord, iteratorVar, output => {
    let initialArraysCode = "";
    let settingCode = "";
    for (let idx = 0, idx_finish = items.length; idx < idx_finish; ++idx) {
      initialArraysCode = initialArraysCode + ("new Array(" + inputVar + ".length),");
      settingCode = settingCode + (outputVar + "[" + idx + "][" + iteratorVar + "]=" + get(output, "toItem.location").i + ";");
    }
    input.a(outputVar + "=[" + initialArraysCode + "]");
    input.c = input.c + settingCode;
  }, input$1 => parse$1(input, undefined));
  let itemCode = merge(input);
  input.c = input.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + itemCode + "}");
  if (itemOutput.f & 1) {
    let newrecord$1 = {...input};
    newrecord$1.f = 1;
    newrecord$1.s = base(arrayTag, false);
    newrecord$1.i = "Promise.all(" + outputVar + ")";
    newrecord$1.v = _notVar;
    return newrecord$1;
  }
  let newrecord$2 = {...input};
  newrecord$2.f = 0;
  newrecord$2.s = base(arrayTag, false);
  newrecord$2.i = outputVar;
  newrecord$2.v = _var;
  return newrecord$2;
}

function unnest(schema) {
  if (schema.type === "object") {
    let properties = schema.properties;
    let keys = Object.keys(properties);
    if (keys.length === 0) {
      throw new Error("[Sury] Invalid empty object for S.unnest schema.");
    }
    let mut = base(arrayTag, false);
    mut.items = keys.map(key => array(properties[key]));
    mut.additionalItems = "strict";
    mut.parser = (input, selfSchema) => {
      let inputTagFlag = flags[input.s.type];
      if (inputTagFlag & 1) {
        input.validation = (inputVar, negative) => (
          negative ? "!" : ""
        ) + "Array.isArray(" + inputVar + ")" + ((
          negative ? "||" : "&&"
        ) + inputVar + ".length" + (
          negative ? "!==" : "==="
        ) + keys.length) + keys.map((param, idx) => (
          negative ? "||" : "&&"
        ) + (
          negative ? "!" : ""
        ) + "Array.isArray(" + inputVar + "[" + idx + "])").join("");
        let mut = base(arrayTag, false);
        let itemSchema = array(unknown);
        mut.items = keys.map(param => itemSchema);
        mut.additionalItems = "strict";
        input.s = mut;
      } else if (inputTagFlag & 128 && input.s.items.length === keys.length && input.s.items.every(s => {
          if (s.type !== arrayTag) {
            return false;
          }
          let match = s.additionalItems;
          return match !== undefined ? match !== "strip" && match !== "strict" : false;
        })) {
        
      } else {
        unsupportedConversion(input, input.s, selfSchema);
      }
      let inputVar = input.v();
      let iteratorVar = varWithoutAllocation(input.g);
      let itemInput = makeObjectVal(input, schema);
      let lengthCode = "";
      for (let idx = 0, idx_finish = keys.length; idx < idx_finish; ++idx) {
        let key = keys[idx];
        add(itemInput, key, next(input, inputVar + "[" + idx + "][" + iteratorVar + "]", input.s.items[idx].additionalItems, undefined));
        lengthCode = lengthCode + (inputVar + "[" + idx + "].length,");
      }
      let output = next(input, "new Array(Math.max(" + lengthCode + "))", selfSchema.to, undefined);
      let outputVar = output.v();
      let itemInput$1 = complete(itemInput);
      let itemOutput = withPathPrepend(itemInput$1, iteratorVar, (bb, itemOutput) => {
        bb.c = bb.c + addKey(output, iteratorVar, itemOutput) + ";";
      }, input => parse$1(input, undefined));
      let itemCode = merge(input);
      input.c = input.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + outputVar + ".length;++" + iteratorVar + "){" + itemCode + "}");
      if (itemOutput.f & 1) {
        return asyncVal(output, "Promise.all(" + output.i + ")");
      } else {
        return output;
      }
    };
    let to = base(arrayTag, false);
    to.items = immutableEmpty$1;
    to.additionalItems = schema;
    to.serializer = unnestSerializer;
    mut.unnest = true;
    mut.to = to;
    return mut;
  }
  throw new Error("[Sury] S.unnest supports only object schemas.");
}

function nullAsOption(item) {
  return factory$2(item, nullAsUnit);
}

function $$null(item) {
  return factory$1([
    item,
    nullLiteral
  ]);
}

function option(item) {
  return factory$2(item, unit);
}

function tuple1(v0) {
  return tuple(s => s.item(0, v0));
}

function tuple2(v0, v1) {
  return definitionToSchema([
    v0,
    v1
  ]);
}

function tuple3(v0, v1, v2) {
  return definitionToSchema([
    v0,
    v1,
    v2
  ]);
}

function intMin(schema, minValue, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
  return addRefinement(schema, metadataId$2, {
    kind: {
      TAG: "Min",
      value: minValue
    },
    message: message
  }, (input, param) => "if(" + input.v() + "<" + embed(input, minValue) + "){" + fail(input, message) + "}");
}

function intMax(schema, maxValue, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
  return addRefinement(schema, metadataId$2, {
    kind: {
      TAG: "Max",
      value: maxValue
    },
    message: message
  }, (input, param) => "if(" + input.v() + ">" + embed(input, maxValue) + "){" + fail(input, message) + "}");
}

function port(schema, message) {
  return internalRefine(schema, mut => {
    mut.format = "port";
    return (input, param) => {
      let inputVar = input.v();
      return inputVar + ">0&&" + inputVar + "<65536&&" + inputVar + "%1===0||" + (
        message !== undefined ? fail(input, message) : embedInvalidInput(input, undefined)
      ) + ";";
    };
  });
}

function floatMin(schema, minValue, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
  return addRefinement(schema, metadataId$3, {
    kind: {
      TAG: "Min",
      value: minValue
    },
    message: message
  }, (input, param) => "if(" + input.v() + "<" + embed(input, minValue) + "){" + fail(input, message) + "}");
}

function floatMax(schema, maxValue, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
  return addRefinement(schema, metadataId$3, {
    kind: {
      TAG: "Max",
      value: maxValue
    },
    message: message
  }, (input, param) => "if(" + input.v() + ">" + embed(input, maxValue) + "){" + fail(input, message) + "}");
}

function arrayMinLength(schema, length, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length + " or more items long";
  return addRefinement(schema, metadataId, {
    kind: {
      TAG: "Min",
      length: length
    },
    message: message
  }, (input, param) => "if(" + input.v() + ".length<" + embed(input, length) + "){" + fail(input, message) + "}");
}

function arrayMaxLength(schema, length, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length + " or fewer items long";
  return addRefinement(schema, metadataId, {
    kind: {
      TAG: "Max",
      length: length
    },
    message: message
  }, (input, param) => "if(" + input.v() + ".length>" + embed(input, length) + "){" + fail(input, message) + "}");
}

function stringMinLength(schema, length, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "String must be " + length + " or more characters long";
  return addRefinement(schema, metadataId$1, {
    kind: {
      TAG: "Min",
      length: length
    },
    message: message
  }, (input, param) => "if(" + input.v() + ".length<" + embed(input, length) + "){" + fail(input, message) + "}");
}

function stringMaxLength(schema, length, maybeMessage) {
  let message = maybeMessage !== undefined ? maybeMessage : "String must be " + length + " or fewer characters long";
  return addRefinement(schema, metadataId$1, {
    kind: {
      TAG: "Max",
      length: length
    },
    message: message
  }, (input, param) => "if(" + input.v() + ".length>" + embed(input, length) + "){" + fail(input, message) + "}");
}

function email(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid email address";
  return addRefinement(schema, metadataId$1, {
    kind: "Email",
    message: message
  }, (input, param) => "if(!" + embed(input, emailRegex) + ".test(" + input.v() + ")){" + fail(input, message) + "}");
}

function uuid(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid UUID";
  return addRefinement(schema, metadataId$1, {
    kind: "Uuid",
    message: message
  }, (input, param) => "if(!" + embed(input, uuidRegex) + ".test(" + input.v() + ")){" + fail(input, message) + "}");
}

function cuid(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid CUID";
  return addRefinement(schema, metadataId$1, {
    kind: "Cuid",
    message: message
  }, (input, param) => "if(!" + embed(input, cuidRegex) + ".test(" + input.v() + ")){" + fail(input, message) + "}");
}

function url(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid url";
  return addRefinement(schema, metadataId$1, {
    kind: "Url",
    message: message
  }, (input, param) => "try{new URL(" + input.v() + ")}catch(_){" + fail(input, message) + "}");
}

function pattern(schema, re, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid pattern";
  return addRefinement(schema, metadataId$1, {
    kind: {
      TAG: "Pattern",
      re: re
    },
    message: message
  }, (input, param) => {
    let embededRe = embed(input, re);
    return (
      re.global ? embededRe + ".lastIndex=0;" : ""
    ) + ("if(!" + embededRe + ".test(" + input.v() + ")){" + fail(input, message) + "}");
  });
}

function datetime(schema, messageOpt) {
  let message = messageOpt !== undefined ? messageOpt : "Invalid datetime string! Expected UTC";
  let refinement = {
    kind: "Datetime",
    message: message
  };
  let refinements = schema[metadataId$1];
  return transform(set(schema, metadataId$1, refinements !== undefined ? refinements.concat(refinement) : [refinement]), s => ({
    p: string => {
      if (!datetimeRe.test(string)) {
        s.fail(message, undefined);
      }
      return new Date(string);
    },
    s: date => date.toISOString()
  }));
}

function trim(schema) {
  let transformer = string => string.trim();
  return transform(schema, param => ({
    p: transformer,
    s: transformer
  }));
}

function nullable(schema) {
  return factory$1([
    schema,
    unit,
    nullLiteral
  ]);
}

function nullableAsOption(schema) {
  return factory$1([
    schema,
    unit,
    nullAsUnit
  ]);
}

let parser$1 = ((...args) => getDecoder(unknown, ...args));

let asyncParser = ((...args) => getDecoder(unknown, ...args, 1));

let asyncDecoder = ((...args) => getDecoder(...args, 1));

let encoder = ((...args) => getDecoder(...args.map(reverse)));

let asyncEncoder = ((...args) => getDecoder(...args.map(reverse), 1));

function js_assert(schema, data) {
  return getDecoder(unknown, schema, assertResult)(data);
}

function js_union(values) {
  return factory$1(values.map(definitionToSchema));
}

function customBuilder(target, fn) {
  return (input, param) => {
    let output = allocateVal(input, target, undefined);
    output.c = "try{" + output.i + "=" + embed(input, fn) + "(" + input.i + ")}catch(x){" + failWithArg(output, e => makeInvalidConversionDetails(input, target, e), "x") + "}";
    return output;
  };
}

function js_to(schema, target, maybeDecoder, maybeEncoder) {
  return updateOutput(schema, mut => {
    let target$1;
    if (maybeEncoder !== undefined) {
      let targetMut = copySchema(target);
      targetMut.serializer = customBuilder(schema, maybeEncoder);
      target$1 = targetMut;
    } else {
      target$1 = target;
    }
    mut.to = target$1;
    if (maybeDecoder !== undefined) {
      mut.parser = customBuilder(target$1, maybeDecoder);
      return;
    }
    
  });
}

function js_refine(schema, refiner) {
  return refine$1(schema, s => (v => refiner(v, s)));
}

function noop(a) {
  return a;
}

function js_asyncParserRefine(schema, refine) {
  return transform(schema, s => ({
    a: v => refine(v, s).then(() => v),
    s: noop
  }));
}

function js_optional(schema, maybeOr) {
  let schema$1 = factory$1([
    schema,
    unit
  ]);
  if (maybeOr === undefined) {
    return schema$1;
  }
  let or = Primitive_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return getWithDefault(schema$1, {
      TAG: "Callback",
      _0: or
    });
  } else {
    return getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    });
  }
}

function js_nullable(schema, maybeOr) {
  let schema$1 = factory$1([
    schema,
    nullAsUnit
  ]);
  if (maybeOr === undefined) {
    return schema$1;
  }
  let or = Primitive_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return getWithDefault(schema$1, {
      TAG: "Callback",
      _0: or
    });
  } else {
    return getWithDefault(schema$1, {
      TAG: "Value",
      _0: or
    });
  }
}

function js_merge(s1, s2) {
  let s;
  if (s1.type === "object" && s2.type === "object") {
    let additionalItems1 = s1.additionalItems;
    if (typeof additionalItems1 === "string" && typeof s2.additionalItems === "string" && !s1.to && !s2.to) {
      let properties2 = s2.properties;
      let properties = copy(s1.properties);
      let keys2 = Object.keys(properties2);
      for (let idx = 0, idx_finish = keys2.length; idx < idx_finish; ++idx) {
        let key = keys2[idx];
        properties[key] = properties2[key];
      }
      let mut = base(objectTag, false);
      mut.properties = properties;
      mut.additionalItems = additionalItems1;
      mut.decoder = objectDecoder;
      s = mut;
    } else {
      s = undefined;
    }
  } else {
    s = undefined;
  }
  if (s !== undefined) {
    return s;
  }
  throw new Error("[Sury] The merge supports only structured object schemas without transformations");
}

function global(override) {
  let defaultAdditionalItems = override.defaultAdditionalItems;
  globalConfig.a = defaultAdditionalItems !== undefined ? defaultAdditionalItems : "strip";
  let match = override.disableNanNumberValidation;
  globalConfig.f = match !== undefined && match ? 2 : 0;
}

let jsonSchemaMetadataId = "m:JSONSchema";

function internalToJSONSchema(schema, path, defs, parent) {
  let jsonSchema = {};
  switch (schema.type) {
    case "never" :
      jsonSchema.not = {};
      break;
    case "string" :
      let $$const = schema.const;
      jsonSchema.type = "string";
      refinements$1(schema).forEach(refinement => {
        let match = refinement.kind;
        if (typeof match !== "object") {
          switch (match) {
            case "Email" :
              jsonSchema.format = "email";
              return;
            case "Uuid" :
              jsonSchema.format = "uuid";
              return;
            case "Cuid" :
              return;
            case "Url" :
              jsonSchema.format = "uri";
              return;
            case "Datetime" :
              jsonSchema.format = "date-time";
              return;
          }
        } else {
          switch (match.TAG) {
            case "Min" :
              jsonSchema.minLength = match.length;
              return;
            case "Max" :
              jsonSchema.maxLength = match.length;
              return;
            case "Length" :
              let length = match.length;
              jsonSchema.minLength = length;
              jsonSchema.maxLength = length;
              return;
            case "Pattern" :
              jsonSchema.pattern = String(match.re);
              return;
          }
        }
      });
      if ($$const !== undefined) {
        jsonSchema.const = $$const;
      }
      break;
    case "number" :
      let format = schema.format;
      let $$const$1 = schema.const;
      if (format !== undefined) {
        if (format === "int32") {
          jsonSchema.type = "integer";
          refinements$2(schema).forEach(refinement => {
            let match = refinement.kind;
            if (match.TAG === "Min") {
              jsonSchema.minimum = match.value;
            } else {
              jsonSchema.maximum = match.value;
            }
          });
        } else {
          jsonSchema.type = "integer";
          jsonSchema.maximum = 65535;
          jsonSchema.minimum = 0;
        }
      } else {
        jsonSchema.type = "number";
        refinements$3(schema).forEach(refinement => {
          let match = refinement.kind;
          if (match.TAG === "Min") {
            jsonSchema.minimum = match.value;
          } else {
            jsonSchema.maximum = match.value;
          }
        });
      }
      if ($$const$1 !== undefined) {
        jsonSchema.const = $$const$1;
      }
      break;
    case "boolean" :
      let $$const$2 = schema.const;
      jsonSchema.type = "boolean";
      if ($$const$2 !== undefined) {
        jsonSchema.const = $$const$2;
      }
      break;
    case "null" :
      jsonSchema.type = "null";
      break;
    case "array" :
      let additionalItems = schema.additionalItems;
      let exit = 0;
      if (additionalItems === "strip" || additionalItems === "strict") {
        exit = 1;
      } else {
        jsonSchema.items = internalToJSONSchema(additionalItems, path + "[]", defs, schema);
        jsonSchema.type = "array";
        refinements(schema).forEach(refinement => {
          let match = refinement.kind;
          switch (match.TAG) {
            case "Min" :
              jsonSchema.minItems = match.length;
              return;
            case "Max" :
              jsonSchema.maxItems = match.length;
              return;
            case "Length" :
              let length = match.length;
              jsonSchema.maxItems = length;
              jsonSchema.minItems = length;
              return;
          }
        });
      }
      if (exit === 1) {
        let items = schema.items.map((itemSchema, idx) => {
          let location = idx.toString();
          return internalToJSONSchema(itemSchema, path + ("[" + fromString(location) + "]"), defs, schema);
        });
        let itemsNumber = items.length;
        jsonSchema.items = Primitive_option.some(items);
        jsonSchema.type = "array";
        jsonSchema.minItems = itemsNumber;
        jsonSchema.maxItems = itemsNumber;
      }
      break;
    case "object" :
      let additionalItems$1 = schema.additionalItems;
      let properties = schema.properties;
      let exit$1 = 0;
      if (additionalItems$1 === "strip" || additionalItems$1 === "strict") {
        exit$1 = 1;
      } else {
        jsonSchema.type = "object";
        jsonSchema.additionalProperties = internalToJSONSchema(additionalItems$1, path + "[]", defs, schema);
      }
      if (exit$1 === 1) {
        let required = [];
        let keys = Object.keys(properties);
        let jsonProperties = {};
        for (let idx = 0, idx_finish = keys.length; idx < idx_finish; ++idx) {
          let key = keys[idx];
          let itemSchema = properties[key];
          let fieldSchema = internalToJSONSchema(itemSchema, path + ("[" + fromString(key) + "]"), defs, schema);
          if (!isOptional(itemSchema)) {
            required.push(key);
          }
          jsonProperties[key] = fieldSchema;
        }
        jsonSchema.type = "object";
        jsonSchema.properties = jsonProperties;
        let tmp;
        tmp = additionalItems$1 === "strip" || additionalItems$1 === "strict" ? additionalItems$1 === "strip" : true;
        jsonSchema.additionalProperties = tmp;
        if (required.length !== 0) {
          jsonSchema.required = required;
        }
        
      }
      break;
    case "union" :
      let literals = [];
      let items$1 = [];
      schema.anyOf.forEach(childSchema => {
        if (childSchema.type === "undefined" && parent.type === objectTag) {
          return;
        }
        items$1.push(internalToJSONSchema(childSchema, path, defs, schema));
        if (constField in childSchema) {
          literals.push(childSchema.const);
          return;
        }
        
      });
      let itemsNumber$1 = items$1.length;
      let $$default = schema.default;
      if ($$default !== undefined) {
        jsonSchema.default = Primitive_option.valFromOption($$default);
      }
      if (itemsNumber$1 === 1) {
        Object.assign(jsonSchema, items$1[0]);
      } else if (literals.length === itemsNumber$1) {
        jsonSchema.enum = literals;
      } else {
        jsonSchema.anyOf = items$1;
      }
      break;
    case "ref" :
      let ref = schema.$ref;
      if (ref === defsPath + jsonName) {
        
      } else {
        jsonSchema.$ref = ref;
      }
      break;
    default:
      throw new SuryError(makeInvalidInputDetails(json, flags[parent.type] & 256 ? parent : schema, path, 0, false, undefined));
  }
  let m = schema.description;
  if (m !== undefined) {
    jsonSchema.description = m;
  }
  let m$1 = schema.title;
  if (m$1 !== undefined) {
    jsonSchema.title = m$1;
  }
  let deprecated = schema.deprecated;
  if (deprecated !== undefined) {
    jsonSchema.deprecated = deprecated;
  }
  let examples = schema.examples;
  if (examples !== undefined) {
    jsonSchema.examples = examples;
  }
  let schemaDefs = schema.$defs;
  if (schemaDefs !== undefined) {
    Object.assign(defs, schemaDefs);
  }
  let metadataRawSchema = schema[jsonSchemaMetadataId];
  if (metadataRawSchema !== undefined) {
    Object.assign(jsonSchema, metadataRawSchema);
  }
  return jsonSchema;
}

function toJSONSchema(schema) {
  let defs = {};
  let jsonSchema = internalToJSONSchema(schema, "", defs, schema);
  ((delete defs.JSON));
  let defsKeys = Object.keys(defs);
  if (defsKeys.length) {
    defsKeys.forEach(key => {
      let schema = defs[key];
      defs[key] = internalToJSONSchema(schema, "", 0, schema);
    });
    jsonSchema.$defs = defs;
  }
  return jsonSchema;
}

function extendJSONSchema(schema, jsonSchema) {
  let existingSchemaExtend = schema[jsonSchemaMetadataId];
  return set(schema, jsonSchemaMetadataId, existingSchemaExtend !== undefined ? Object.assign({}, existingSchemaExtend, jsonSchema) : jsonSchema);
}

let primitiveToSchema = parse;

function toIntSchema(jsonSchema) {
  let minimum = jsonSchema.minimum;
  let schema;
  if (minimum !== undefined) {
    schema = intMin(int, minimum | 0, undefined);
  } else {
    let exclusiveMinimum = jsonSchema.exclusiveMinimum;
    schema = exclusiveMinimum !== undefined ? intMin(int, exclusiveMinimum + 1 | 0, undefined) : int;
  }
  let maximum = jsonSchema.maximum;
  if (maximum !== undefined) {
    return intMax(schema, maximum | 0, undefined);
  }
  let exclusiveMinimum$1 = jsonSchema.exclusiveMinimum;
  if (exclusiveMinimum$1 !== undefined) {
    return intMax(schema, exclusiveMinimum$1 - 1 | 0, undefined);
  } else {
    return schema;
  }
}

function definitionToDefaultValue(definition) {
  if (typeof definition !== "object") {
    return;
  } else {
    return definition.default;
  }
}

function fromJSONSchema(jsonSchema) {
  let definitionToSchema$1 = definition => {
    if (typeof definition !== "object") {
      if (definition === false) {
        return never;
      } else {
        return json;
      }
    } else {
      return fromJSONSchema(definition);
    }
  };
  let type_ = jsonSchema.type;
  let schema;
  let exit = 0;
  let exit$1 = 0;
  if (jsonSchema.nullable) {
    schema = $$null(fromJSONSchema(Object.assign({}, jsonSchema, {
      nullable: false
    })));
  } else if (type_ !== undefined) {
    let type_$1 = Primitive_option.valFromOption(type_);
    if (type_$1 === "object") {
      let properties = jsonSchema.properties;
      if (properties !== undefined) {
        let obj = {};
        let schema$1 = definitionToSchema((Object.keys(properties).forEach(key => {
          let property = properties[key];
          let propertySchema = definitionToSchema$1(property);
          let r = jsonSchema.required;
          let propertySchema$1;
          let exit = 0;
          if (r !== undefined && r.includes(key)) {
            propertySchema$1 = propertySchema;
          } else {
            exit = 1;
          }
          if (exit === 1) {
            let defaultValue = definitionToDefaultValue(property);
            if (defaultValue !== undefined) {
              let schema = option(propertySchema);
              propertySchema$1 = getWithDefault(schema, {
                TAG: "Value",
                _0: defaultValue
              });
            } else {
              propertySchema$1 = option(propertySchema);
            }
          }
          obj[key] = propertySchema$1;
        }), obj));
        let additionalProperties = jsonSchema.additionalProperties;
        schema = additionalProperties === false ? strict(schema$1) : schema$1;
      } else {
        let additionalProperties$1 = jsonSchema.additionalProperties;
        schema = additionalProperties$1 !== undefined ? (
            typeof additionalProperties$1 !== "object" ? (
                additionalProperties$1 === false ? strict(object(param => {})) : factory(json)
              ) : factory(fromJSONSchema(additionalProperties$1))
          ) : definitionToSchema();
      }
    } else if (type_$1 === "array") {
      let items = jsonSchema.items;
      let schema$2;
      if (items !== undefined) {
        let single = JSONSchema.Arrayable.classify(Primitive_option.valFromOption(items));
        if (single.TAG === "Single") {
          schema$2 = array(definitionToSchema$1(single._0));
        } else {
          let array$1 = single._0;
          schema$2 = tuple(s => array$1.map((d, idx) => s.item(idx, definitionToSchema$1(d))));
        }
      } else {
        schema$2 = array(json);
      }
      let min = jsonSchema.minItems;
      let schema$3 = min !== undefined ? arrayMinLength(schema$2, min, undefined) : schema$2;
      let max = jsonSchema.maxItems;
      schema = max !== undefined ? arrayMaxLength(schema$3, max, undefined) : schema$3;
    } else {
      exit$1 = 2;
    }
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    let primitives = jsonSchema.enum;
    let definitions = jsonSchema.allOf;
    let definitions$1 = jsonSchema.anyOf;
    if (definitions$1 !== undefined) {
      let len = definitions$1.length;
      schema = len !== 1 ? (
          len !== 0 ? factory$1(definitions$1.map(definitionToSchema$1)) : json
        ) : definitionToSchema$1(definitions$1[0]);
    } else if (definitions !== undefined) {
      let len$1 = definitions.length;
      schema = len$1 !== 1 ? (
          len$1 !== 0 ? refine$1(json, s => (data => {
              definitions.forEach(d => {
                try {
                  return assertOrThrow(data, definitionToSchema$1(d));
                } catch (exn) {
                  return s.fail("Should pass for all schemas of the allOf property.", undefined);
                }
              });
            })) : json
        ) : definitionToSchema$1(definitions[0]);
    } else {
      let definitions$2 = jsonSchema.oneOf;
      if (definitions$2 !== undefined) {
        let len$2 = definitions$2.length;
        schema = len$2 !== 1 ? (
            len$2 !== 0 ? refine$1(json, s => (data => {
                let hasOneValidRef = {
                  contents: false
                };
                definitions$2.forEach(d => {
                  let passed;
                  try {
                    assertOrThrow(data, definitionToSchema$1(d));
                    passed = true;
                  } catch (exn) {
                    passed = false;
                  }
                  if (passed) {
                    if (hasOneValidRef.contents) {
                      s.fail("Should pass single schema according to the oneOf property.", undefined);
                    }
                    hasOneValidRef.contents = true;
                    return;
                  }
                  
                });
                if (!hasOneValidRef.contents) {
                  return s.fail("Should pass at least one schema according to the oneOf property.", undefined);
                }
                
              })) : json
          ) : definitionToSchema$1(definitions$2[0]);
      } else {
        let not = jsonSchema.not;
        if (not !== undefined) {
          schema = refine$1(json, s => (data => {
            let passed;
            try {
              assertOrThrow(data, definitionToSchema$1(not));
              passed = true;
            } catch (exn) {
              passed = false;
            }
            if (passed) {
              return s.fail("Should NOT be valid against schema in the not property.", undefined);
            }
            
          }));
        } else if (primitives !== undefined) {
          let len$3 = primitives.length;
          schema = len$3 !== 1 ? (
              len$3 !== 0 ? factory$1(primitives.map(primitiveToSchema)) : json
            ) : parse(primitives[0]);
        } else {
          let $$const = jsonSchema.const;
          if ($$const !== undefined) {
            schema = parse($$const);
          } else if (type_ !== undefined) {
            let type_$2 = Primitive_option.valFromOption(type_);
            let exit$2 = 0;
            let exit$3 = 0;
            if (Array.isArray(type_$2)) {
              schema = factory$1(type_$2.map(type_ => fromJSONSchema(Object.assign({}, jsonSchema, {
                type: Primitive_option.some(type_)
              }))));
            } else if (type_$2 === "string") {
              let p = jsonSchema.pattern;
              let schema$4 = p !== undefined ? pattern(string, new RegExp(p), undefined) : string;
              let minLength = jsonSchema.minLength;
              let schema$5 = minLength !== undefined ? stringMinLength(schema$4, minLength, undefined) : schema$4;
              let maxLength = jsonSchema.maxLength;
              let schema$6 = maxLength !== undefined ? stringMaxLength(schema$5, maxLength, undefined) : schema$5;
              switch (jsonSchema.format) {
                case "date-time" :
                  schema = datetime(schema$6, undefined);
                  break;
                case "email" :
                  schema = email(schema$6, undefined);
                  break;
                case "uri" :
                  schema = url(schema$6, undefined);
                  break;
                case "uuid" :
                  schema = uuid(schema$6, undefined);
                  break;
                default:
                  schema = schema$6;
              }
            } else if (type_$2 === "integer" || jsonSchema.format === "int64" && type_$2 === "number") {
              schema = toIntSchema(jsonSchema);
            } else {
              exit$3 = 4;
            }
            if (exit$3 === 4) {
              if (jsonSchema.multipleOf !== 1 || type_$2 !== "number") {
                exit$2 = 3;
              } else {
                schema = toIntSchema(jsonSchema);
              }
            }
            if (exit$2 === 3) {
              if (type_$2 === "number") {
                let minimum = jsonSchema.minimum;
                let schema$7;
                if (minimum !== undefined) {
                  schema$7 = floatMin(float, minimum, undefined);
                } else {
                  let exclusiveMinimum = jsonSchema.exclusiveMinimum;
                  schema$7 = exclusiveMinimum !== undefined ? floatMin(float, exclusiveMinimum + 1, undefined) : float;
                }
                let maximum = jsonSchema.maximum;
                if (maximum !== undefined) {
                  schema = floatMax(schema$7, maximum, undefined);
                } else {
                  let exclusiveMinimum$1 = jsonSchema.exclusiveMinimum;
                  schema = exclusiveMinimum$1 !== undefined ? floatMax(schema$7, exclusiveMinimum$1 - 1, undefined) : schema$7;
                }
              } else if (type_$2 === "boolean") {
                schema = bool;
              } else if (type_$2 === "null") {
                schema = js_schema(null);
              } else {
                exit = 1;
              }
            }
            
          } else {
            exit = 1;
          }
        }
      }
    }
  }
  if (exit === 1) {
    let if_ = jsonSchema.if;
    if (if_ !== undefined) {
      let then = jsonSchema.then;
      if (then !== undefined) {
        let else_ = jsonSchema.else;
        if (else_ !== undefined) {
          let ifSchema = definitionToSchema$1(if_);
          let thenSchema = definitionToSchema$1(then);
          let elseSchema = definitionToSchema$1(else_);
          schema = refine$1(json, param => (data => {
            let passed;
            try {
              assertOrThrow(data, ifSchema);
              passed = true;
            } catch (exn) {
              passed = false;
            }
            if (passed) {
              return assertOrThrow(data, thenSchema);
            } else {
              return assertOrThrow(data, elseSchema);
            }
          }));
        } else {
          schema = json;
        }
      } else {
        schema = json;
      }
    } else {
      schema = json;
    }
  }
  if (jsonSchema.description === undefined && jsonSchema.deprecated === undefined && jsonSchema.examples === undefined && jsonSchema.title === undefined) {
    return schema;
  }
  return meta(schema, {
    title: jsonSchema.title,
    description: jsonSchema.description,
    deprecated: jsonSchema.deprecated,
    examples: jsonSchema.examples
  });
}

function min(schema, minValue, maybeMessage) {
  switch (schema.type) {
    case "string" :
      return stringMinLength(schema, minValue, maybeMessage);
    case "number" :
      if (schema.format !== undefined) {
        return intMin(schema, minValue, maybeMessage);
      } else {
        return floatMin(schema, minValue, maybeMessage);
      }
    case "array" :
      return arrayMinLength(schema, minValue, maybeMessage);
    default:
      let message = "S.min is not supported for " + toExpression(schema) + " schema. Coerce the schema to string, number or array using S.to first.";
      throw new Error("[Sury] " + message);
  }
}

function max(schema, maxValue, maybeMessage) {
  switch (schema.type) {
    case "string" :
      return stringMaxLength(schema, maxValue, maybeMessage);
    case "number" :
      if (schema.format !== undefined) {
        return intMax(schema, maxValue, maybeMessage);
      } else {
        return floatMax(schema, maxValue, maybeMessage);
      }
    case "array" :
      return arrayMaxLength(schema, maxValue, maybeMessage);
    default:
      let message = "S.max is not supported for " + toExpression(schema) + " schema. Coerce the schema to string, number or array using S.to first.";
      throw new Error("[Sury] " + message);
  }
}

function length(schema, length$1, maybeMessage) {
  switch (schema.type) {
    case "string" :
      let message = maybeMessage !== undefined ? maybeMessage : "String must be exactly " + length$1 + " characters long";
      return addRefinement(schema, metadataId$1, {
        kind: {
          TAG: "Length",
          length: length$1
        },
        message: message
      }, (input, param) => "if(" + input.v() + ".length!==" + embed(input, length$1) + "){" + fail(input, message) + "}");
    case "array" :
      let message$1 = maybeMessage !== undefined ? maybeMessage : "Array must be exactly " + length$1 + " items long";
      return addRefinement(schema, metadataId, {
        kind: {
          TAG: "Length",
          length: length$1
        },
        message: message$1
      }, (input, param) => "if(" + input.v() + ".length!==" + embed(input, length$1) + "){" + fail(input, message$1) + "}");
    default:
      let message$2 = "S.length is not supported for " + toExpression(schema) + " schema. Coerce the schema to string or array using S.to first.";
      throw new Error("[Sury] " + message$2);
  }
}

let Path = {
  empty: "",
  dynamic: "[]",
  toArray: toArray,
  fromArray: fromArray,
  fromLocation: fromLocation,
  concat: concat
};

let literal = js_schema;

let dict = factory;

let union = factory$1;

let Schema$1 = {};

let schema = factory$3;

let $$Object = {};

let Option = {
  getOr: getOr,
  getOrWith: getOrWith
};

let String_Refinement = {};

let $$String$1 = {
  Refinement: String_Refinement,
  refinements: refinements$1
};

let Int_Refinement = {};

let Int = {
  Refinement: Int_Refinement,
  refinements: refinements$2
};

let Float_Refinement = {};

let Float = {
  Refinement: Float_Refinement,
  refinements: refinements$3
};

let Array_Refinement = {};

let $$Array$1 = {
  Refinement: Array_Refinement,
  refinements: refinements
};

let Metadata = {
  Id: Id,
  get: get$1,
  set: set
};

export {
  Path,
  Exn,
  never,
  unknown,
  unit,
  nullAsUnit,
  string,
  bool,
  int,
  float,
  bigint,
  symbol,
  json,
  enableJson,
  jsonString,
  jsonStringWithSpace,
  enableJsonString,
  uint8Array,
  enableUint8Array,
  literal,
  array,
  unnest,
  list,
  instance,
  dict,
  option,
  $$null,
  nullAsOption,
  nullable,
  nullableAsOption,
  union,
  $$enum,
  meta,
  transform,
  refine$1 as refine,
  shape,
  to,
  makeConvertOrThrow,
  makeAsyncConvertOrThrow,
  parseOrThrow,
  parseJsonOrThrow,
  parseJsonStringOrThrow,
  parseAsyncOrThrow,
  convertOrThrow,
  convertToJsonOrThrow,
  convertToJsonStringOrThrow,
  convertAsyncOrThrow,
  reverseConvertOrThrow,
  reverseConvertToJsonOrThrow,
  reverseConvertToJsonStringOrThrow,
  assertOrThrow,
  isAsync,
  recursive,
  noValidation,
  toExpression,
  Schema$1 as Schema,
  schema,
  $$Object,
  object,
  strip,
  deepStrip,
  strict,
  deepStrict,
  Tuple,
  tuple,
  tuple1,
  tuple2,
  tuple3,
  Option,
  $$String$1 as $$String,
  Int,
  Float,
  $$Array$1 as $$Array,
  Metadata,
  reverse,
  $$Error$1 as $$Error,
  min,
  floatMin,
  max,
  floatMax,
  length,
  port,
  email,
  uuid,
  cuid,
  url,
  pattern,
  datetime,
  trim,
  toJSONSchema,
  fromJSONSchema,
  extendJSONSchema,
  global,
  brand,
  parser$1 as parser,
  asyncParser,
  getDecoder,
  asyncDecoder,
  encoder,
  asyncEncoder,
  js_assert,
  js_safe,
  js_safeAsync,
  js_union,
  js_optional,
  js_nullable,
  js_asyncParserRefine,
  js_refine,
  js_to,
  js_schema,
  js_merge,
}
/* s Not a pure module */
