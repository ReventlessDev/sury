// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "sury/src/S.res.mjs";
import * as U from "../utils/U.res.mjs";
import Ava from "ava";

let variantSchema = S.union([
  S.literal("One"),
  S.literal("Two")
]);

Ava("Variant", t => U.assertEqualSchemas(t, variantSchema, S.union([
  S.literal("One"),
  S.literal("Two")
]), undefined));

let variantWithSingleItemSchema = S.literal("Single");

Ava("Variant with single item becomes a literal schema of the item", t => U.assertEqualSchemas(t, variantWithSingleItemSchema, S.literal("Single"), undefined));

let variantWithAliasSchema = S.union([
  S.literal("하나"),
  S.literal("Two")
]);

Ava("Variant with partial @as usage", t => U.assertEqualSchemas(t, variantWithAliasSchema, S.union([
  S.literal("하나"),
  S.literal("Two")
]), undefined));

let variantWithPayloadsSchema = S.union([
  S.literal("Constant"),
  S.schema(s => ({
    TAG: "SinglePayload",
    _0: s.m(S.int)
  })),
  S.schema(s => ({
    TAG: "TuplePayload",
    _0: s.m(S.int),
    _1: s.m(S.string)
  })),
  S.schema(s => ({
    TAG: "RecordPayload",
    foo: s.m(S.float)
  }))
]);

Ava("Variant with payloads", t => U.assertEqualSchemas(t, variantWithPayloadsSchema, S.union([
  S.literal("Constant"),
  S.schema(s => ({
    TAG: "SinglePayload",
    _0: s.m(S.int)
  })),
  S.schema(s => ({
    TAG: "TuplePayload",
    _0: s.m(S.int),
    _1: s.m(S.string)
  })),
  S.schema(s => ({
    TAG: "RecordPayload",
    foo: s.m(S.float)
  }))
]), undefined));

let unboxedVariantSchema = S.union([
  S.literal("Constant"),
  S.schema(s => (s.m(S.int))),
  S.schema(s => (s.m(S.string)))
]);

Ava("Unboxed variant", t => U.assertEqualSchemas(t, unboxedVariantSchema, S.union([
  S.literal("Constant"),
  S.schema(s => (s.m(S.int))),
  S.schema(s => (s.m(S.string)))
]), undefined));

let taggedVariantSchema = S.union([
  S.schema(s => ({
    kind: "circle",
    radius: s.m(S.float)
  })),
  S.schema(s => ({
    kind: "square",
    x: s.m(S.float)
  })),
  S.schema(s => ({
    kind: "triangle",
    x: s.m(S.float),
    y: s.m(S.float)
  }))
]);

Ava("Tagged variant", t => U.assertEqualSchemas(t, taggedVariantSchema, S.union([
  S.schema(s => ({
    kind: "circle",
    radius: s.m(S.float)
  })),
  S.schema(s => ({
    kind: "square",
    x: s.m(S.float)
  })),
  S.schema(s => ({
    kind: "triangle",
    x: s.m(S.float),
    y: s.m(S.float)
  }))
]), undefined));

let variantWithMetaSchema = S.meta(S.union([
  S.literal("One"),
  S.literal("Two")
]), {
  description: "A variant with meta"
});

Ava("Variant with @s.meta", t => U.assertEqualSchemas(t, variantWithMetaSchema, S.meta(S.union([
  S.literal("One"),
  S.literal("Two")
]), {
  description: "A variant with meta"
}), undefined));

let variantWithConstructorMetaSchema = S.union([
  S.meta(S.literal("One"), {
    description: "The first one"
  }),
  S.literal("Two")
]);

Ava("Variant with @s.meta on constructor", t => U.assertEqualSchemas(t, variantWithConstructorMetaSchema, S.union([
  S.meta(S.literal("One"), {
    description: "The first one"
  }),
  S.literal("Two")
]), undefined));

let taggedInlinedAliasSchema = S.union([
  S.schema(s => ({
    type: "Foo",
    Foo: s.m(S.string)
  })),
  S.schema(s => ({
    type: "Bar",
    Bar: s.m(S.string)
  }))
]);

Ava("Tagged variant with inlined alias", t => U.assertEqualSchemas(t, taggedInlinedAliasSchema, S.union([
  S.schema(s => ({
    type: "Foo",
    Foo: s.m(S.string)
  })),
  S.schema(s => ({
    type: "Bar",
    Bar: s.m(S.string)
  }))
]), undefined));

let variantWithExposeSchema = S.union([
  S.expose(S.literal("One")),
  S.literal("Two")
]);

Ava("Variant with @s.expose on no-payload constructor", t => U.assertEqualSchemas(t, variantWithExposeSchema, S.union([
  S.expose(S.literal("One")),
  S.literal("Two")
]), undefined));

let variantWithExposePayloadSchema = S.union([
  S.expose(S.schema(s => ({
    TAG: "WithPayload",
    _0: s.m(S.int)
  }))),
  S.literal("Without")
]);

Ava("Variant with @s.expose on payload constructor", t => U.assertEqualSchemas(t, variantWithExposePayloadSchema, S.union([
  S.expose(S.schema(s => ({
    TAG: "WithPayload",
    _0: s.m(S.int)
  }))),
  S.literal("Without")
]), undefined));

export {
  variantSchema,
  variantWithSingleItemSchema,
  variantWithAliasSchema,
  variantWithPayloadsSchema,
  unboxedVariantSchema,
  taggedVariantSchema,
  variantWithMetaSchema,
  variantWithConstructorMetaSchema,
  taggedInlinedAliasSchema,
  variantWithExposeSchema,
  variantWithExposePayloadSchema,
}
/* variantSchema Not a pure module */
